<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>量子電路控制 - 量子視覺藝術化專案</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            line-height: 1.6;
            padding: 2rem;
        }

        .header {
            text-align: center;
            padding: 2rem;
            color: white;
            margin-bottom: 2rem;
        }

        .header h1 {
            font-size: 3rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #fff, #e0e7ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .navigation {
            text-align: center;
            margin-bottom: 2rem;
        }

        .nav-link {
            display: inline-block;
            margin: 0 1rem;
            padding: 0.75rem 1.5rem;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            text-decoration: none;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .main-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            gap: 2rem;
        }

        .circuit-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .parameters-panel {
            width: 400px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .controls-row {
            display: flex;
            gap: 2rem;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-weight: 600;
            color: #4c1d95;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group input {
            padding: 0.75rem 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
            width: 100px;
        }

        .control-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .clear-all-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            min-width: 120px;
        }

        .clear-all-button:hover {
            background: linear-gradient(135deg, #dc2626, #b91c1c);
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        }

        .clear-all-button:active {
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }

        .clear-all-button:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* 量子門樣式 */
        td[data-gate="H"] { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        td[data-gate="X"] { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
        td[data-gate="Y"] { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; }
        td[data-gate="Z"] { background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; }
        td[data-gate="S"] { background: linear-gradient(135deg, #14b8a6, #0f766e); color: white; }
        td[data-gate="C"] { background: linear-gradient(135deg, #06b6d4, #0891b2); color: white; }
        td[data-gate="D"] { background: linear-gradient(135deg, #ec4899, #db2777); color: white; }

        /* CNOT門樣式 */
        .cnot-control {
            position: relative;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .cnot-target {
            position: relative;
            font-size: 1.5rem;
            font-weight: bold;
        }

        /* Toffoli門樣式 */
        .toffoli-control1, .toffoli-control2 {
            position: relative;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .toffoli-target {
            position: relative;
            font-size: 1.5rem;
            font-weight: bold;
        }

        .gates-section {
            margin-bottom: 2rem;
        }

        .gates-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #4c1d95;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .gates-container {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .gate {
            padding: 1rem 1.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 15px;
            cursor: grab;
            font-weight: 700;
            font-size: 1.1rem;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            border: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            min-width: 60px;
            text-align: center;
        }

        .gate:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.4);
        }

        .gate:active {
            cursor: grabbing;
            transform: translateY(-1px) scale(0.98);
        }

        .circuit-container {
            background: rgba(248, 250, 252, 0.9);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            overflow-x: auto;
        }

        .circuit-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #4c1d95;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        table {
            border-collapse: separate;
            border-spacing: 8px;
            width: 100%;
            min-width: 400px;
        }

        td {
            border: 2px solid #e5e7eb;
            text-align: center;
            padding: 0.75rem;
            min-width: 60px;
            height: 60px;
            position: relative;
            border-radius: 12px;
            background: white;
            transition: all 0.3s ease;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
        }

        td:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);
        }

        td[data-gate="H"] { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        td[data-gate="X"] { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
        td[data-gate="Y"] { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; }
        td[data-gate="Z"] { background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; }
        td[data-gate="S"] { background: linear-gradient(135deg, #14b8a6, #0f766e); color: white; }
        td[data-gate="C"] { background: linear-gradient(135deg, #06b6d4, #0891b2); color: white; }
        td[data-gate="D"] { background: linear-gradient(135deg, #ec4899, #db2777); color: white; }

        .qubit-labels {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-right: 1rem;
            align-items: center;
            justify-content: flex-start;
            padding-top: 1rem;
        }

        .qubit-label {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: #4c1d95;
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border-radius: 12px;
            min-width: 50px;
            border: 2px solid #bae6fd;
            font-size: 0.9rem;
        }

        .circuit-wrapper {
            display: flex;
            align-items: flex-start;
        }

        select {
            font-size: 0.7rem;
            margin: 2px 0;
            padding: 0.2rem;
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 6px;
            background: rgba(255,255,255,0.9);
            color: #333;
        }

        .output-section {
            background: rgba(248, 250, 252, 0.9);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .output-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #4c1d95;
            margin-bottom: 1rem;
        }

        pre {
            background: linear-gradient(135deg, #1f2937, #374151);
            color: #f9fafb;
            padding: 1rem;
            border-radius: 12px;
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            white-space: pre-wrap;
            line-height: 1.4;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
            border: 1px solid #4b5563;
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .parameters-display {
            background: rgba(248, 250, 252, 0.9);
            border-radius: 12px;
            padding: 1rem;
            font-size: 0.85rem;
        }

        .param-item {
            display: flex;
            flex-direction: column;
            margin-bottom: 0.8rem;
            padding: 0.5rem;
            border-bottom: 1px solid rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
        }

        .param-item > div:first-child {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .param-label {
            font-weight: 600;
            color: #4c1d95;
        }

        .param-value {
            color: #6b7280;
            font-family: monospace;
        }

        .param-source {
            font-size: 0.75rem;
            color: #9ca3af;
            font-style: italic;
            background: rgba(248, 250, 252, 0.8);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            border-left: 3px solid #e5e7eb;
            margin-top: 0.25rem;
        }

        .action-buttons {
            margin-top: 1.5rem;
            display: flex;
            gap: 1rem;
        }

        .action-button {
            flex: 1;
            padding: 1rem;
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            text-align: center;
            display: block;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(16, 185, 129, 0.4);
        }

        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>
<body>
    <div class="header fade-in">
        <h1>量子電路控制</h1>
        <p>設計和調整量子電路，控制視覺藝術生成參數</p>
    </div>

    <div class="navigation fade-in">
        <a href="index.html" class="nav-link">← 回到首頁</a>
        <a href="visual_canvas.html" class="nav-link">查看視覺畫布</a>
        <a href="verybbpaint.html" class="nav-link">完整整合視圖</a>
    </div>

    <div class="main-container">
        <div class="circuit-panel fade-in">
            <div class="controls-row">
                <div class="control-group">
                    <label>量子位元</label>
                    <input type="number" id="numQubits" min="1" max="6" value="3" onchange="renderCircuit()">
                </div>
                <div class="control-group">
                    <label>欄位數</label>
                    <input type="number" id="numCols" min="1" max="12" value="6" onchange="renderCircuit()">
                </div>
                <div class="control-group">
                    <label>電路控制</label>
                    <button class="clear-all-button" onclick="clearAllGates()">清除所有門</button>
                </div>
            </div>
            
            <div class="gates-section">
                <div class="gates-title">量子閘</div>
                <div class="gates-container">
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="H" title="Hadamard Gate">H</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="X" title="Pauli-X Gate">X</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="Y" title="Pauli-Y Gate">Y</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="Z" title="Pauli-Z Gate">Z</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="S" title="Phase Gate (S Gate)">S</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="C" title="CNOT Gate">C</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="D" title="Toffoli Gate">D</div>
                </div>
            </div>

            <div class="circuit-container">
                <div class="circuit-title">量子電路設計</div>
                <div class="circuit-wrapper">
                    <div class="qubit-labels" id="qubitLabels"></div>
                    <table id="circuitTable"></table>
                </div>
            </div>

            <div class="output-section">
                <div class="output-title">量子態向量</div>
                <pre id="output">拖拽量子閘到電路中查看量子態演化...</pre>
            </div>
        </div>

        <div class="parameters-panel fade-in">
            <div class="output-title">繪畫參數</div>
            <div class="parameters-display">
                <div id="parametersDisplay">
                    <div class="param-item">
                        <div>
                            <span class="param-label">粒子數量:</span>
                            <span class="param-value" id="particleCountDisplay">1000</span>
                        </div>
                        <div class="param-source" id="particleCountSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">粒子尺寸係數:</span>
                            <span class="param-value" id="particleSizeDisplay">40</span>
                        </div>
                        <div class="param-source" id="particleSizeSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">主色調 (R,G,B):</span>
                            <span class="param-value" id="mainColorDisplay">(0, 20, 90)</span>
                        </div>
                        <div class="param-source" id="mainColorSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">色彩變化幅度:</span>
                            <span class="param-value" id="colorVariationDisplay">30</span>
                        </div>
                        <div class="param-source" id="colorVariationSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">粒子衰減率:</span>
                            <span class="param-value" id="decayRateDisplay">0.9675</span>
                        </div>
                        <div class="param-source" id="decayRateSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">旋轉因子:</span>
                            <span class="param-value" id="rotationFactorDisplay">0.002</span>
                        </div>
                        <div class="param-source" id="rotationFactorSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">陰影位移 (X,Y):</span>
                            <span class="param-value" id="shadowOffsetDisplay">(3.2, 3.2)</span>
                        </div>
                        <div class="param-source" id="shadowOffsetSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">背景色 (R,G,B):</span>
                            <span class="param-value" id="bgColorDisplay">(255, 255, 255)</span>
                        </div>
                        <div class="param-source" id="bgColorSource">初始值</div>
                    </div>
                </div>
            </div>

            <div class="action-buttons">
                <a href="visual_canvas.html" class="action-button">生成藝術作品</a>
            </div>
        </div>
    </div>

    <script>
        // 量子電路參數
        let circuitMeta = {};
        let quantumParameters = {
            particleCount: 1000,
            particleSize: 40,
            randomColor: 50,
            mainRed: 0,
            mainGreen: 20,
            mainBlue: 90,
            colorVariation: 30,
            decayRate: 0.9675,
            rotationFactor: 0.002,
            shadowX: 3.2,
            shadowY: 3.2,
            bgRed: 255,
            bgGreen: 255,
            bgBlue: 255
        };

        // 參數計算來源記錄
        let parameterSources = {
            particleCount: "初始值",
            particleSize: "初始值", 
            mainRed: "初始值",
            mainGreen: "初始值",
            mainBlue: "初始值",
            colorVariation: "初始值",
            decayRate: "初始值",
            rotationFactor: "初始值",
            shadowX: "初始值",
            shadowY: "初始值",
            bgRed: "初始值",
            bgGreen: "初始值",
            bgBlue: "初始值"
        };

        // 量子電路功能
        function handleDrag(ev) {
            ev.dataTransfer.setData("text", ev.target.dataset.gate);
            ev.target.style.opacity = '0.5';
        }

        function handleDragEnd(ev) {
            ev.target.style.opacity = '1';
        }

        function allowDrop(ev) { 
            ev.preventDefault(); 
            const currentGate = ev.currentTarget.getAttribute('data-gate');
            if (!currentGate) {
                ev.currentTarget.style.background = 'rgba(102, 126, 234, 0.1)';
            }
        }

        function handleDragLeave(ev) {
            const currentGate = ev.currentTarget.getAttribute('data-gate');
            if (!currentGate) {
                ev.currentTarget.style.background = 'white';
            }
        }

        function drop(ev) {
            ev.preventDefault();
            
            const currentGate = ev.currentTarget.getAttribute('data-gate');
            if (!currentGate) {
                ev.currentTarget.style.background = '';
            }
            
            const gate = ev.dataTransfer.getData("text");
            const td = ev.target.closest('td');
            if (!td) return;
            
            const row = td.parentElement.rowIndex;
            const col = td.cellIndex;
            
            td.style.transform = 'scale(1.1)';
            setTimeout(() => {
                td.style.transform = '';
            }, 200);

            if (gate === "C") {
                // CNOT門需要選擇控制位和目標位
                const controlQubit = prompt("請選擇控制位 (0-" + (+document.getElementById("numQubits").value - 1) + "):");
                const targetQubit = prompt("請選擇目標位 (0-" + (+document.getElementById("numQubits").value - 1) + "):");
                
                if (controlQubit === null || targetQubit === null || 
                    controlQubit === targetQubit || 
                    isNaN(controlQubit) || isNaN(targetQubit) ||
                    controlQubit < 0 || targetQubit < 0 ||
                    controlQubit >= +document.getElementById("numQubits").value ||
                    targetQubit >= +document.getElementById("numQubits").value) {
                    return; // 取消或輸入無效
                }
                
                // 設置CNOT門占據兩個格子
                setCNOTGate(col, parseInt(controlQubit), parseInt(targetQubit));
            } else if (gate === "D") {
                // Toffoli門需要選擇兩個控制位和一個目標位
                const numQubits = +document.getElementById("numQubits").value;
                const control1Qubit = prompt("請選擇第一個控制位 (0-" + (numQubits - 1) + "):");
                const control2Qubit = prompt("請選擇第二個控制位 (0-" + (numQubits - 1) + "):");
                const targetQubit = prompt("請選擇目標位 (0-" + (numQubits - 1) + "):");
                
                if (control1Qubit === null || control2Qubit === null || targetQubit === null || 
                    control1Qubit === control2Qubit || control1Qubit === targetQubit || control2Qubit === targetQubit ||
                    isNaN(control1Qubit) || isNaN(control2Qubit) || isNaN(targetQubit) ||
                    control1Qubit < 0 || control2Qubit < 0 || targetQubit < 0 ||
                    control1Qubit >= numQubits || control2Qubit >= numQubits || targetQubit >= numQubits) {
                    return; // 取消或輸入無效
                }
                
                // 設置Toffoli門占據三個格子
                setToffoliGate(col, parseInt(control1Qubit), parseInt(control2Qubit), parseInt(targetQubit));
            } else {
                td.textContent = gate;
                td.setAttribute("data-gate", gate);
            }
            simulate();
        }

        function clearGate(ev) {
            if (ev.target.tagName === "SELECT" || ev.target.tagName === "OPTION") return;
            
            const td = ev.currentTarget;
            td.style.transform = 'scale(0.9)';
            setTimeout(() => {
                td.style.transform = '';
            }, 150);
            
            // 如果是CNOT門，需要特殊處理
            if (td.getAttribute("data-gate") === "C" && td.hasAttribute("data-cnot-role")) {
                clearCNOTGate(td);
            } else if (td.getAttribute("data-gate") === "D" && td.hasAttribute("data-toffoli-role")) {
                // 如果是Toffoli門，需要特殊處理
                clearToffoliGate(td);
            } else {
                // 普通門的清除
                td.textContent = "";
                td.setAttribute("data-gate", "");
                td.removeAttribute("data-col");
                
                // 清除可能的量子門相關樣式
                td.classList.remove('cnot-control', 'cnot-target', 'toffoli-control1', 'toffoli-control2', 'toffoli-target');
            }
            
            simulate();
        }

        function clearAllGates() {
            const table = document.getElementById("circuitTable");
            if (!table || !table.rows.length) {
                alert("沒有電路可以清除！");
                return;
            }
            
            // 檢查是否有門需要清除
            let hasGates = false;
            for (let r = 0; r < table.rows.length; r++) {
                for (let c = 0; c < table.rows[r].cells.length; c++) {
                    const cell = table.rows[r].cells[c];
                    const gate = cell.getAttribute("data-gate");
                    if (gate && gate !== "") {
                        hasGates = true;
                        break;
                    }
                }
                if (hasGates) break;
            }
            
            if (!hasGates) {
                alert("電路中沒有門需要清除！");
                return;
            }
            
            // 確認對話框
            if (!confirm("確定要清除所有量子門嗎？此操作無法復原。")) {
                return;
            }
            
            // 禁用按鈕並顯示處理狀態
            const button = document.querySelector('.clear-all-button');
            const originalText = button.textContent;
            button.disabled = true;
            button.textContent = "清除中...";
            
            // 清除所有門，添加動畫效果
            let delay = 0;
            for (let r = 0; r < table.rows.length; r++) {
                for (let c = 0; c < table.rows[r].cells.length; c++) {
                    const cell = table.rows[r].cells[c];
                    const gate = cell.getAttribute("data-gate");
                    
                    if (gate && gate !== "") {
                        setTimeout(() => {
                            // 添加清除動畫
                            cell.style.transform = 'scale(0.8)';
                            cell.style.opacity = '0.5';
                            
                            setTimeout(() => {
                                // 清除所有屬性和樣式
                                cell.textContent = "";
                                cell.setAttribute("data-gate", "");
                                cell.removeAttribute("data-col");
                                cell.removeAttribute("data-cnot-role");
                                cell.removeAttribute("data-cnot-partner");
                                cell.removeAttribute("data-cnot-col");
                                cell.removeAttribute("data-toffoli-role");
                                cell.removeAttribute("data-toffoli-control1");
                                cell.removeAttribute("data-toffoli-control2");
                                cell.removeAttribute("data-toffoli-target");
                                cell.removeAttribute("data-toffoli-col");
                                cell.classList.remove('cnot-control', 'cnot-target', 'toffoli-control1', 'toffoli-control2', 'toffoli-target');
                                cell.title = '';
                                cell.style.transform = '';
                                cell.style.opacity = '';
                            }, 150);
                        }, delay);
                        delay += 50; // 錯開動畫時間
                    }
                }
            }
            
            // 在所有動畫完成後重新啟用按鈕並執行模擬
            setTimeout(() => {
                button.disabled = false;
                button.textContent = originalText;
                simulate();
                alert("所有量子門已成功清除！");
            }, delay + 200);
        }

        function setCNOTGate(col, controlQubit, targetQubit) {
            const table = document.getElementById("circuitTable");
            const rows = table.querySelectorAll('tr');
            
            // 檢查指定位置是否已經有門
            if (rows[controlQubit] && rows[controlQubit].cells[col] && 
                rows[controlQubit].cells[col].getAttribute('data-gate') !== '') {
                alert(`位置 (q${controlQubit}, col${col}) 已經有量子門！`);
                return;
            }
            
            if (rows[targetQubit] && rows[targetQubit].cells[col] && 
                rows[targetQubit].cells[col].getAttribute('data-gate') !== '') {
                alert(`位置 (q${targetQubit}, col${col}) 已經有量子門！`);
                return;
            }
            
            // 設置控制位格子
            if (rows[controlQubit] && rows[controlQubit].cells[col]) {
                const controlCell = rows[controlQubit].cells[col];
                controlCell.classList.add('cnot-control');
                controlCell.setAttribute('data-gate', 'C');
                controlCell.setAttribute('data-cnot-role', 'control');
                controlCell.setAttribute('data-cnot-partner', targetQubit);
                controlCell.setAttribute('data-cnot-col', col);
                controlCell.textContent = '●';
                controlCell.title = `CNOT控制位 → q${targetQubit}`;
            }
            
            // 設置目標位格子
            if (rows[targetQubit] && rows[targetQubit].cells[col]) {
                const targetCell = rows[targetQubit].cells[col];
                targetCell.classList.add('cnot-target');
                targetCell.setAttribute('data-gate', 'C');
                targetCell.setAttribute('data-cnot-role', 'target');
                targetCell.setAttribute('data-cnot-partner', controlQubit);
                targetCell.setAttribute('data-cnot-col', col);
                targetCell.textContent = '⊕';
                targetCell.title = `CNOT目標位 ← q${controlQubit}`;
            }
            
            simulate();
        }

        function clearCNOTGate(cell) {
            const col = parseInt(cell.getAttribute('data-cnot-col'));
            const partner = parseInt(cell.getAttribute('data-cnot-partner'));
            const table = document.getElementById("circuitTable");
            const rows = table.querySelectorAll('tr');
            
            // 清除當前格子
            cell.classList.remove('cnot-control', 'cnot-target');
            cell.textContent = '';
            cell.setAttribute('data-gate', '');
            cell.removeAttribute('data-cnot-role');
            cell.removeAttribute('data-cnot-partner');
            cell.removeAttribute('data-cnot-col');
            cell.title = '';
            
            // 清除夥伴格子
            if (rows[partner] && rows[partner].cells[col]) {
                const partnerCell = rows[partner].cells[col];
                partnerCell.classList.remove('cnot-control', 'cnot-target');
                partnerCell.textContent = '';
                partnerCell.setAttribute('data-gate', '');
                partnerCell.removeAttribute('data-cnot-role');
                partnerCell.removeAttribute('data-cnot-partner');
                partnerCell.removeAttribute('data-cnot-col');
                partnerCell.title = '';
            }
        }

        function setToffoliGate(col, control1Qubit, control2Qubit, targetQubit) {
            const table = document.getElementById("circuitTable");
            const rows = table.querySelectorAll('tr');
            
            // 檢查指定位置是否已經有門
            const positions = [control1Qubit, control2Qubit, targetQubit];
            for (const pos of positions) {
                if (rows[pos] && rows[pos].cells[col] && 
                    rows[pos].cells[col].getAttribute('data-gate') !== '') {
                    alert(`位置 (q${pos}, col${col}) 已經有量子門！`);
                    return;
                }
            }
            
            // 設置第一個控制位格子
            if (rows[control1Qubit] && rows[control1Qubit].cells[col]) {
                const control1Cell = rows[control1Qubit].cells[col];
                control1Cell.classList.add('toffoli-control1');
                control1Cell.setAttribute('data-gate', 'D');
                control1Cell.setAttribute('data-toffoli-role', 'control1');
                control1Cell.setAttribute('data-toffoli-control2', control2Qubit);
                control1Cell.setAttribute('data-toffoli-target', targetQubit);
                control1Cell.setAttribute('data-toffoli-col', col);
                control1Cell.textContent = '●';
                control1Cell.title = `Toffoli控制位1 → q${targetQubit} (與q${control2Qubit})`;
            }
            
            // 設置第二個控制位格子
            if (rows[control2Qubit] && rows[control2Qubit].cells[col]) {
                const control2Cell = rows[control2Qubit].cells[col];
                control2Cell.classList.add('toffoli-control2');
                control2Cell.setAttribute('data-gate', 'D');
                control2Cell.setAttribute('data-toffoli-role', 'control2');
                control2Cell.setAttribute('data-toffoli-control1', control1Qubit);
                control2Cell.setAttribute('data-toffoli-target', targetQubit);
                control2Cell.setAttribute('data-toffoli-col', col);
                control2Cell.textContent = '●';
                control2Cell.title = `Toffoli控制位2 → q${targetQubit} (與q${control1Qubit})`;
            }
            
            // 設置目標位格子
            if (rows[targetQubit] && rows[targetQubit].cells[col]) {
                const targetCell = rows[targetQubit].cells[col];
                targetCell.classList.add('toffoli-target');
                targetCell.setAttribute('data-gate', 'D');
                targetCell.setAttribute('data-toffoli-role', 'target');
                targetCell.setAttribute('data-toffoli-control1', control1Qubit);
                targetCell.setAttribute('data-toffoli-control2', control2Qubit);
                targetCell.setAttribute('data-toffoli-col', col);
                targetCell.textContent = '⊕';
                targetCell.title = `Toffoli目標位 ← q${control1Qubit} & q${control2Qubit}`;
            }
            
            simulate();
        }

        function clearToffoliGate(cell) {
            const col = parseInt(cell.getAttribute('data-toffoli-col'));
            const table = document.getElementById("circuitTable");
            const rows = table.querySelectorAll('tr');
            
            // 在同一列中找到所有屬於Toffoli門的格子
            for (let r = 0; r < rows.length; r++) {
                const currentCell = rows[r].cells[col];
                if (currentCell && 
                    currentCell.getAttribute('data-gate') === 'D' && 
                    currentCell.hasAttribute('data-toffoli-role') &&
                    parseInt(currentCell.getAttribute('data-toffoli-col')) === col) {
                    
                    // 清除這個格子
                    currentCell.classList.remove('toffoli-control1', 'toffoli-control2', 'toffoli-target');
                    currentCell.textContent = '';
                    currentCell.setAttribute('data-gate', '');
                    currentCell.removeAttribute('data-toffoli-role');
                    currentCell.removeAttribute('data-toffoli-control1');
                    currentCell.removeAttribute('data-toffoli-control2');
                    currentCell.removeAttribute('data-toffoli-target');
                    currentCell.removeAttribute('data-toffoli-col');
                    currentCell.title = '';
                }
            }
        }

        function makeQubitOptions() {
            const nq = +document.getElementById("numQubits").value;
            return Array.from({length: nq}, (_, i) => `<option value='${i}'>q${i}</option>`).join('');
        }

        function renderCircuit() {
            const nq = +document.getElementById("numQubits").value;
            const nc = +document.getElementById("numCols").value;
            const table = document.getElementById("circuitTable");
            const labels = document.getElementById("qubitLabels");
            
            table.innerHTML = "";
            labels.innerHTML = "";
            
            for (let r = 0; r < nq; r++) {
                const label = document.createElement("div");
                label.className = "qubit-label";
                label.textContent = `|q${r}⟩`;
                labels.appendChild(label);
            }
            
            for (let r = 0; r < nq; r++) {
                const row = document.createElement("tr");
                for (let c = 0; c < nc; c++) {
                    const cell = document.createElement("td");
                    cell.setAttribute("data-gate", "");
                    cell.ondrop = drop;
                    cell.ondragover = allowDrop;
                    cell.ondragleave = handleDragLeave;
                    cell.onclick = clearGate;
                    row.appendChild(cell);
                }
                table.appendChild(row);
            }
            simulate();
        }

        // 量子運算
        const H = [[1/Math.sqrt(2),1/Math.sqrt(2)],[1/Math.sqrt(2),-1/Math.sqrt(2)]];
        const X = [[0,1],[1,0]];
        const Y = [[0, math.complex(0, -1)],[math.complex(0, 1), 0]];
        const Z = [[1,0],[0,-1]];
        const S = [[1,0],[0, math.complex(0, 1)]]; // Phase gate (S gate)
        const I = [[1,0],[0,1]];

        function kron(a, b) {
            const result = [];
            for (let i = 0; i < a.length; i++) {
                for (let j = 0; j < b.length; j++) {
                    result.push(a[i].map(x => b[j].map(y => math.multiply(x, y))).flat());
                }
            }
            return result;
        }

        function applyGate(state, matrix) {
            const res = Array(state.length).fill(0).map(_ => math.complex(0, 0));
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix.length; j++) {
                    res[i] = math.add(res[i], math.multiply(matrix[i][j], state[j]));
                }
            }
            return res;
        }

        function createCNOT(n, control, target) {
            const size = 1 << n;
            const mat = Array.from({ length: size }, () => Array(size).fill(math.complex(0, 0)));
            for (let i = 0; i < size; i++) {
                const bit = (i >> (n - 1 - control)) & 1;
                let j = i;
                if (bit) j ^= (1 << (n - 1 - target));
                mat[j][i] = math.complex(1, 0);
            }
            return mat;
        }

        function createToffoli(n, c1, c2, target) {
            const size = 1 << n;
            const mat = Array.from({ length: size }, () => Array(size).fill(math.complex(0, 0)));
            for (let i = 0; i < size; i++) {
                const b1 = (i >> (n - 1 - c1)) & 1;
                const b2 = (i >> (n - 1 - c2)) & 1;
                let j = i;
                if (b1 && b2) j ^= (1 << (n - 1 - target));
                mat[j][i] = math.complex(1, 0);
            }
            return mat;
        }

        // HSV到RGB的轉換函數
        function hsvToRgb(h, s, v) {
            h = h / 60; // 將色調轉換到0-6範圍
            const c = v * s; // 彩度
            const x = c * (1 - Math.abs((h % 2) - 1));
            const m = v - c;
            
            let r, g, b;
            
            if (h >= 0 && h < 1) {
                r = c; g = x; b = 0;
            } else if (h >= 1 && h < 2) {
                r = x; g = c; b = 0;
            } else if (h >= 2 && h < 3) {
                r = 0; g = c; b = x;
            } else if (h >= 3 && h < 4) {
                r = 0; g = x; b = c;
            } else if (h >= 4 && h < 5) {
                r = x; g = 0; b = c;
            } else {
                r = c; g = 0; b = x;
            }
            
            return {
                r: Math.round((r + m) * 255),
                g: Math.round((g + m) * 255),
                b: Math.round((b + m) * 255)
            };
        }

        function mapQuantumStateToParameters(state, numQubits) {
            const nonZeroStates = [];
            const amplitudes = [];
            
            for (let i = 0; i < state.length; i++) {
                const amplitude = math.abs(state[i]);
                if (amplitude > 1e-6) {
                    const bin = i.toString(2).padStart(numQubits, '0');
                    nonZeroStates.push({
                        state: bin,
                        amplitude: amplitude,
                        complex: state[i],
                        index: i
                    });
                    amplitudes.push(amplitude);
                }
            }
            
            if (nonZeroStates.length === 0) return;
            
            // 使用量子態振幅來映射到參數
            const totalAmplitude = amplitudes.reduce((sum, amp) => sum + amp, 0);
            const weightedSum = nonZeroStates.reduce((sum, s) => sum + s.amplitude * s.index, 0);
            const maxIndex = Math.max(...nonZeroStates.map(s => s.index));
            
            // 映射邏輯：將量子態的特性轉換為繪畫參數，並記錄計算來源
            quantumParameters.particleCount = Math.floor(500 + (weightedSum / totalAmplitude) * 700);
            parameterSources.particleCount = `加權和(${weightedSum.toFixed(3)}) / 總振幅(${totalAmplitude.toFixed(3)})`;
            
            quantumParameters.particleSize = Math.floor(20 + (amplitudes[0] || 0) * 80);
            parameterSources.particleSize = `第一態振幅: ${(amplitudes[0] || 0).toFixed(3)} (|${nonZeroStates[0]?.state || '000'}⟩)`;
            
            quantumParameters.randomColor = 50;
            
            // 使用HSV色彩空間來控制主色調
            const firstAmplitude = amplitudes[0] || 0;
            const secondAmplitude = amplitudes[1] || 0;
            const firstComplex = nonZeroStates[0]?.complex || math.complex(0, 0);
            
            // 計算HSV值
            // H (色調): 使用第一個量子態的相位角度 (0-360度)
            const phase = math.arg(firstComplex); // 相位角度 (-π 到 π)
            const hue = ((phase + Math.PI) / (2 * Math.PI)) * 360; // 轉換到0-360度
            
            // S (飽和度): 使用第一個量子態的振幅 (0-1)
            const saturation = firstAmplitude;
            
            // V (明度): 使用第二個量子態的振幅，如果沒有第二態則使用0.8
            const value = nonZeroStates[1] ? secondAmplitude : 0.8;
            
            // 將HSV轉換為RGB
            const rgb = hsvToRgb(hue, saturation, value);
            
            quantumParameters.mainRed = Math.floor(rgb.r);
            quantumParameters.mainGreen = Math.floor(rgb.g);
            quantumParameters.mainBlue = Math.floor(rgb.b);
            
            parameterSources.mainRed = `HSV轉RGB - H:${hue.toFixed(1)}° S:${saturation.toFixed(3)} V:${value.toFixed(3)}`;
            parameterSources.mainGreen = `色調來自第一態相位: ${phase.toFixed(3)}rad (|${nonZeroStates[0]?.state || '000'}⟩)`;
            parameterSources.mainBlue = nonZeroStates[1] ? 
                `飽和度=${saturation.toFixed(3)}, 明度來自第二態: ${value.toFixed(3)} (|${nonZeroStates[1].state}⟩)` : 
                `飽和度=${saturation.toFixed(3)}, 明度預設: ${value.toFixed(3)}`;
            
            quantumParameters.colorVariation = Math.floor(nonZeroStates.length * 10);
            parameterSources.colorVariation = `非零態數量: ${nonZeroStates.length}`;
            
            quantumParameters.decayRate = 0.95 + (amplitudes[0] || 0) * 0.04;
            parameterSources.decayRate = `0.95 + 第一態振幅(${(amplitudes[0] || 0).toFixed(3)}) × 0.04`;
            
            // 使用第一態和第二態振幅的乘積控制旋轉因子
            quantumParameters.rotationFactor = nonZeroStates[1] ? 
                (firstAmplitude * secondAmplitude) * 0.01 :
                (firstAmplitude * firstAmplitude) * 0.01;
            parameterSources.rotationFactor = nonZeroStates[1] ? 
                `第一態振幅(${firstAmplitude.toFixed(3)}) × 第二態振幅(${secondAmplitude.toFixed(3)}) × 0.01` :
                `僅一個非零態，使用振幅平方: ${firstAmplitude.toFixed(3)}² × 0.01`;
            
            // 使用不同量子態控制陰影
            if (nonZeroStates.length > 1) {
                const shadowRealPart = math.re(nonZeroStates[1].complex);
                const shadowImagPart = math.im(nonZeroStates[1].complex);
                
                quantumParameters.shadowX = Math.abs(shadowRealPart) * 10;
                parameterSources.shadowX = `第二態實部絕對值: ${Math.abs(shadowRealPart).toFixed(3)} (|${nonZeroStates[1].state}⟩)`;
                
                quantumParameters.shadowY = Math.abs(shadowImagPart) * 10;
                parameterSources.shadowY = `第二態虛部絕對值: ${Math.abs(shadowImagPart).toFixed(3)} (|${nonZeroStates[1].state}⟩)`;
            } else {
                parameterSources.shadowX = "僅一個非零態，使用預設值";
                parameterSources.shadowY = "僅一個非零態，使用預設值";
            }
            
            // 背景顏色基於總體量子態分佈
            const entropy = -nonZeroStates.reduce((sum, s) => {
                const p = s.amplitude / totalAmplitude;
                return sum + p * Math.log2(p);
            }, 0);
            
            quantumParameters.bgRed = Math.floor(200 + entropy * 10);
            quantumParameters.bgGreen = Math.floor(200 + entropy * 10);
            quantumParameters.bgBlue = Math.floor(200 + entropy * 10);
            parameterSources.bgRed = `熵值: ${entropy.toFixed(3)}`;
            parameterSources.bgGreen = `熵值: ${entropy.toFixed(3)}`;
            parameterSources.bgBlue = `熵值: ${entropy.toFixed(3)}`;
            
            // 更新顯示
            updateParameterDisplay();
            
            // 儲存參數到localStorage
            localStorage.setItem('quantumParameters', JSON.stringify(quantumParameters));
            localStorage.setItem('parameterSources', JSON.stringify(parameterSources));
        }

        function updateParameterDisplay() {
            document.getElementById('particleCountDisplay').textContent = quantumParameters.particleCount;
            document.getElementById('particleSizeDisplay').textContent = quantumParameters.particleSize;
            document.getElementById('mainColorDisplay').textContent = `(${quantumParameters.mainRed}, ${quantumParameters.mainGreen}, ${quantumParameters.mainBlue})`;
            document.getElementById('colorVariationDisplay').textContent = quantumParameters.colorVariation;
            document.getElementById('decayRateDisplay').textContent = quantumParameters.decayRate.toFixed(4);
            document.getElementById('rotationFactorDisplay').textContent = quantumParameters.rotationFactor.toFixed(4);
            document.getElementById('shadowOffsetDisplay').textContent = `(${quantumParameters.shadowX.toFixed(1)}, ${quantumParameters.shadowY.toFixed(1)})`;
            document.getElementById('bgColorDisplay').textContent = `(${quantumParameters.bgRed}, ${quantumParameters.bgGreen}, ${quantumParameters.bgBlue})`;
            
            // 更新參數來源顯示
            document.getElementById('particleCountSource').textContent = parameterSources.particleCount;
            document.getElementById('particleSizeSource').textContent = parameterSources.particleSize;
            document.getElementById('mainColorSource').textContent = `R: ${parameterSources.mainRed} | G: ${parameterSources.mainGreen} | B: ${parameterSources.mainBlue}`;
            document.getElementById('colorVariationSource').textContent = parameterSources.colorVariation;
            document.getElementById('decayRateSource').textContent = parameterSources.decayRate;
            document.getElementById('rotationFactorSource').textContent = parameterSources.rotationFactor;
            document.getElementById('shadowOffsetSource').textContent = `X: ${parameterSources.shadowX} | Y: ${parameterSources.shadowY}`;
            document.getElementById('bgColorSource').textContent = parameterSources.bgRed;
        }

        function simulate() {
            const nq = +document.getElementById("numQubits").value;
            const table = document.getElementById("circuitTable");
            if (!table.rows.length) return;
            
            const nc = table.rows[0].cells.length;
            let state = Array(1 << nq).fill(math.complex(0, 0));
            state[0] = math.complex(1, 0);

            for (let c = 0; c < nc; c++) {
                let hasCNOT = false;
                let processedCNOT = new Set(); // 避免重複處理同一個CNOT門
                let processedToffoli = new Set(); // 避免重複處理同一個Toffoli門
                
                for (let r = 0; r < nq; r++) {
                    const cell = table.rows[r].cells[c];
                    const g = cell.getAttribute("data-gate") || "I";
                    if (g === "C" && cell.hasAttribute("data-cnot-role")) {
                        const cnotCol = cell.getAttribute("data-cnot-col");
                        const role = cell.getAttribute("data-cnot-role");
                        const partner = parseInt(cell.getAttribute("data-cnot-partner"));
                        
                        // 只在控制位處理CNOT門，避免重複
                        if (role === "control" && !processedCNOT.has(`${cnotCol}-${r}-${partner}`)) {
                            const control = r;
                            const target = partner;
                            const U = createCNOT(nq, control, target);
                            state = applyGate(state, U);
                            hasCNOT = true;
                            processedCNOT.add(`${cnotCol}-${r}-${partner}`);
                        }
                    } else if (g === "D" && cell.hasAttribute("data-toffoli-role")) {
                        const toffoliCol = cell.getAttribute("data-toffoli-col");
                        const role = cell.getAttribute("data-toffoli-role");
                        const control1 = parseInt(cell.getAttribute("data-toffoli-control1"));
                        const control2 = parseInt(cell.getAttribute("data-toffoli-control2"));
                        const target = parseInt(cell.getAttribute("data-toffoli-target"));
                        
                        // 只在第一個控制位處理Toffoli門，避免重複
                        if (role === "control1" && !processedToffoli.has(`${toffoliCol}-${control1}-${control2}-${target}`)) {
                            console.log(`處理Toffoli門: 控制位1=${control1}, 控制位2=${control2}, 目標位=${target}`);
                            const toffoliMatrix = createToffoli(nq, control1, control2, target);
                            state = math.multiply(toffoliMatrix, state);
                            hasCNOT = true;
                            processedToffoli.add(`${toffoliCol}-${control1}-${control2}-${target}`);
                        }
                    }
                }
                if (!hasCNOT) {
                    const gates = [];
                    for (let r = 0; r < nq; r++) {
                        const cell = table.rows[r].cells[c];
                        const g = cell.getAttribute("data-gate") || "I";
                        // 跳過CNOT門和Toffoli門的格子，因為它們已經在上面處理過了
                        if ((g === "C" && cell.hasAttribute("data-cnot-role")) || 
                            (g === "D" && cell.hasAttribute("data-toffoli-role"))) {
                            gates.push(I); // 多位門的格子用單位矩陣
                        } else {
                            gates.push(({ H, X, Y, Z, S, I })[g] || I);
                        }
                    }
                    const U = gates.reduce((a, b) => kron(a, b));
                    state = applyGate(state, U);
                }
            }

            let out = "";
            const nonZeroStates = [];
            for (let i = 0; i < state.length; i++) {
                if (math.abs(state[i]) > 1e-6) {
                    const bin = i.toString(2).padStart(nq, '0');
                    nonZeroStates.push(`${state[i].toString()} |${bin}⟩`);
                }
            }
            
            if (nonZeroStates.length > 0) {
                out = nonZeroStates.join('\n');
            } else {
                out = "沒有找到顯著的振幅態。";
            }
            
            document.getElementById("output").textContent = out;
            
            // 將量子態映射到繪畫參數
            mapQuantumStateToParameters(state, nq);
        }

        // 初始化量子電路
        document.addEventListener('DOMContentLoaded', function() {
            renderCircuit();
            updateParameterDisplay();
            
            // 添加 dragend 事件到所有量子閘
            document.querySelectorAll('.gate').forEach(gate => {
                gate.addEventListener('dragend', handleDragEnd);
            });
        });
    </script>
</body>
</html> 