<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>量子視覺藝術化專案</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
        }

        .navigation {
            text-align: center;
            padding: 1rem 2rem 0;
        }

        .nav-link {
            display: inline-block;
            padding: 0.75rem 1.5rem;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            text-decoration: none;
            border-radius: 10px;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .nav-link:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .header {
            text-align: center;
            padding: 2rem;
            color: white;
        }

        .header h1 {
            font-size: 3.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #fff, #e0e7ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .header p {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 1rem;
        }

        .main-container {
            display: flex;
            gap: 2rem;
            padding: 0 2rem 2rem;
            flex: 1;
        }

        .circuit-panel {
            width: 600px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 2rem;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            max-height: calc(100vh - 200px);
            overflow-y: auto;
        }

        .canvas-container {
            flex: 1;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 1rem;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
        }

        .canvas-controls {
            text-align: center;
            padding: 1rem 0;
            border-top: 1px solid rgba(0,0,0,0.1);
            margin-top: 1rem;
        }

        .download-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
        }

        .download-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(245, 158, 11, 0.4);
        }

        .download-button:active {
            transform: translateY(0);
        }

        .clear-all-button {
            padding: 0.75rem 1.5rem;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.3);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .clear-all-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(239, 68, 68, 0.4);
            background: linear-gradient(135deg, #dc2626, #b91c1c);
        }

        .clear-all-button:active {
            transform: translateY(0);
        }

        canvas {
            background: transparent !important;
            position: relative !important;
            width: 100% !important;
            height: calc(100vh - 300px) !important;
            border-radius: 15px;
        }

        .controls-row {
            display: flex;
            gap: 2rem;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
            font-weight: 600;
            color: #4c1d95;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group input {
            padding: 0.75rem 1rem;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: white;
            width: 100px;
        }

        .control-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .gates-section {
            margin-bottom: 2rem;
        }

        .gates-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: #4c1d95;
            margin-bottom: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .gates-container {
            display: flex;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .gate {
            padding: 1rem 1.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-radius: 15px;
            cursor: grab;
            font-weight: 700;
            font-size: 1.1rem;
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
            border: none;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            user-select: none;
            min-width: 60px;
            text-align: center;
        }

        .gate:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 15px 35px rgba(102, 126, 234, 0.4);
        }

        .gate:active {
            cursor: grabbing;
            transform: translateY(-1px) scale(0.98);
        }

        .circuit-container {
            background: rgba(248, 250, 252, 0.9);
            border-radius: 15px;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
            overflow-x: auto;
        }

        .circuit-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #4c1d95;
            margin-bottom: 1.5rem;
            text-align: center;
        }

        table {
            border-collapse: separate;
            border-spacing: 8px;
            width: 100%;
            min-width: 400px;
        }

        td {
            border: 2px solid #e5e7eb;
            text-align: center;
            padding: 0.75rem;
            min-width: 60px;
            height: 60px;
            position: relative;
            border-radius: 12px;
            background: white;
            transition: all 0.3s ease;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
        }

        td:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.2);
        }

        td[data-gate="H"] { background: linear-gradient(135deg, #10b981, #059669); color: white; }
        td[data-gate="X"] { background: linear-gradient(135deg, #ef4444, #dc2626); color: white; }
        td[data-gate="Y"] { background: linear-gradient(135deg, #f59e0b, #d97706); color: white; }
        td[data-gate="Z"] { background: linear-gradient(135deg, #8b5cf6, #7c3aed); color: white; }
        td[data-gate="S"] { background: linear-gradient(135deg, #14b8a6, #0f766e); color: white; }
        td[data-gate="C"] { background: linear-gradient(135deg, #06b6d4, #0891b2); color: white; }
        td[data-gate="D"] { background: linear-gradient(135deg, #ec4899, #db2777); color: white; }
        
        .cnot-control {
            background: linear-gradient(135deg, #06b6d4, #0891b2) !important;
            color: white !important;
            position: relative;
        }
        
        .cnot-target {
            background: linear-gradient(135deg, #0891b2, #0369a1) !important;
            color: white !important;
            position: relative;
        }
        
        .cnot-control {
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .cnot-target {
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .toffoli-control1 {
            background: linear-gradient(135deg, #ec4899, #db2777) !important;
            color: white !important;
            position: relative;
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .toffoli-control2 {
            background: linear-gradient(135deg, #db2777, #be185d) !important;
            color: white !important;
            position: relative;
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .toffoli-target {
            background: linear-gradient(135deg, #be185d, #9d174d) !important;
            color: white !important;
            position: relative;
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        


        .qubit-labels {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-right: 1rem;
            align-items: center;
            justify-content: flex-start;
            padding-top: 1rem;
        }

        .qubit-label {
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            color: #4c1d95;
            background: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            border-radius: 12px;
            min-width: 50px;
            border: 2px solid #bae6fd;
            font-size: 0.9rem;
        }

        .circuit-wrapper {
            display: flex;
            align-items: flex-start;
        }

        select {
            font-size: 0.7rem;
            margin: 2px 0;
            padding: 0.2rem;
            border: 1px solid rgba(255,255,255,0.5);
            border-radius: 6px;
            background: rgba(255,255,255,0.9);
            color: #333;
        }

        .output-section {
            background: rgba(248, 250, 252, 0.9);
            border-radius: 15px;
            padding: 1.5rem;
        }

        .output-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #4c1d95;
            margin-bottom: 1rem;
        }

        pre {
            background: linear-gradient(135deg, #1f2937, #374151);
            color: #f9fafb;
            padding: 1rem;
            border-radius: 12px;
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            white-space: pre-wrap;
            line-height: 1.4;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.3);
            border: 1px solid #4b5563;
            font-size: 0.8rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .fade-in {
            animation: fadeIn 0.6s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .parameters-display {
            background: rgba(248, 250, 252, 0.9);
            border-radius: 12px;
            padding: 1rem;
            margin-top: 1rem;
            font-size: 0.85rem;
        }

        .param-item {
            display: flex;
            flex-direction: column;
            margin-bottom: 0.8rem;
            padding: 0.5rem;
            border-bottom: 1px solid rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 0.5);
            border-radius: 8px;
        }

        .param-item > div:first-child {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.3rem;
        }

        .param-label {
            font-weight: 600;
            color: #4c1d95;
        }

        .param-value {
            color: #6b7280;
            font-family: monospace;
        }

        .param-source {
            font-size: 0.75rem;
            color: #9ca3af;
            font-style: italic;
            background: rgba(248, 250, 252, 0.8);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            border-left: 3px solid #e5e7eb;
            margin-top: 0.25rem;
        }
    </style>
</head>
<body>
    <div class="navigation fade-in">
        <a href="/quartum/index.html" class="nav-link">← 回到首頁</a>
    </div>

    <div class="header fade-in">
        <h1>量子視覺藝術化專案</h1>
        <p>透過量子電路控制視覺生成參數，創造獨特的量子藝術作品</p>
    </div>

    <div class="main-container">
        <div class="circuit-panel">
            <div class="controls-row">
                <div class="control-group">
                    <label>量子位元</label>
                    <input type="number" id="numQubits" min="1" max="6" value="3" onchange="renderCircuit()">
                </div>
                <div class="control-group">
                    <label>欄位數</label>
                    <input type="number" id="numCols" min="1" max="12" value="6" onchange="renderCircuit()">
                </div>
                <div class="control-group">
                    <label>電路控制</label>
                    <button class="clear-all-button" onclick="clearAllGates()" title="清除電路中的所有量子門">
                        清除所有門
                    </button>
                </div>
            </div>
            
            <div class="gates-section">
                <div class="gates-title">量子閘</div>
                <div class="gates-container">
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="H" title="Hadamard Gate">H</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="X" title="Pauli-X Gate">X</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="Y" title="Pauli-Y Gate">Y</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="Z" title="Pauli-Z Gate">Z</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="S" title="Phase Gate (S Gate)">S</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="C" title="CNOT Gate">C</div>
                    <div class="gate" draggable="true" ondragstart="handleDrag(event)" data-gate="D" title="Toffoli Gate">D</div>
                </div>
            </div>

            <div class="circuit-container">
                <div class="circuit-title">量子電路設計</div>
                <div class="circuit-wrapper">
                    <div class="qubit-labels" id="qubitLabels"></div>
                    <table id="circuitTable"></table>
                </div>
            </div>

            <div class="output-section">
                <div class="output-title">量子態向量</div>
                <pre id="output">拖拽量子閘到電路中查看量子態演化...</pre>
            </div>

            <div class="parameters-display">
                <div class="output-title">繪畫參數</div>
                <div id="parametersDisplay">
                    <div class="param-item">
                        <div>
                            <span class="param-label">粒子數量:</span>
                            <span class="param-value" id="particleCountDisplay">1000</span>
                        </div>
                        <div class="param-source" id="particleCountSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">粒子尺寸係數:</span>
                            <span class="param-value" id="particleSizeDisplay">40</span>
                        </div>
                        <div class="param-source" id="particleSizeSource">初始值</div>
                    </div>

                    <div class="param-item">
                        <div>
                            <span class="param-label">主色調 (R,G,B):</span>
                            <span class="param-value" id="mainColorDisplay">(0, 20, 90)</span>
                        </div>
                        <div class="param-source" id="mainColorSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">色彩變化幅度:</span>
                            <span class="param-value" id="colorVariationDisplay">30</span>
                        </div>
                        <div class="param-source" id="colorVariationSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">粒子衰減率:</span>
                            <span class="param-value" id="decayRateDisplay">0.9675</span>
                        </div>
                        <div class="param-source" id="decayRateSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">旋轉因子:</span>
                            <span class="param-value" id="rotationFactorDisplay">0.002</span>
                        </div>
                        <div class="param-source" id="rotationFactorSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">陰影位移 (X,Y):</span>
                            <span class="param-value" id="shadowOffsetDisplay">(3.2, 3.2)</span>
                        </div>
                        <div class="param-source" id="shadowOffsetSource">初始值</div>
                    </div>
                    <div class="param-item">
                        <div>
                            <span class="param-label">背景色 (R,G,B):</span>
                            <span class="param-value" id="bgColorDisplay">(255, 255, 255)</span>
                        </div>
                        <div class="param-source" id="bgColorSource">初始值</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="canvas-container">
            <div id="canvasWrapper"></div>
            <div class="canvas-controls">
                <button class="download-button" onclick="downloadArtwork()">
                    下載藝術作品
                </button>
            </div>
        </div>
    </div>
    <script>
        // noprotect

// 量子電路參數
let circuitMeta = {};
let quantumParameters = {
    particleCount: 1000,
    particleSize: 40,
    randomColor: 38,
    mainRed: 0,
    mainGreen: 20,
    mainBlue: 90,
    colorVariation: 30,
    decayRate: 0.9675,
    rotationFactor: 0.002,
    shadowX: 3.2,
    shadowY: 3.2,
    bgRed: 255,
    bgGreen: 255,
    bgBlue: 255
};

// 參數計算來源記錄
let parameterSources = {
    particleCount: "初始值",
    particleSize: "初始值", 
    mainRed: "初始值",
    mainGreen: "初始值",
    mainBlue: "初始值",
    colorVariation: "初始值",
    decayRate: "初始值",
    rotationFactor: "初始值",
    shadowX: "初始值",
    shadowY: "初始值",
    bgRed: "初始值",
    bgGreen: "初始值",
    bgBlue: "初始值"
};

// 量子電路功能
function handleDrag(ev) {
    ev.dataTransfer.setData("text", ev.target.dataset.gate);
    ev.target.style.opacity = '0.5';
}

function handleDragEnd(ev) {
    ev.target.style.opacity = '1';
}

function allowDrop(ev) { 
    ev.preventDefault(); 
    const currentGate = ev.currentTarget.getAttribute('data-gate');
    if (!currentGate) {
        ev.currentTarget.style.background = 'rgba(102, 126, 234, 0.1)';
    }
}

function handleDragLeave(ev) {
    const currentGate = ev.currentTarget.getAttribute('data-gate');
    if (!currentGate) {
        ev.currentTarget.style.background = 'white';
    }
}

function drop(ev) {
    ev.preventDefault();
    
    const currentGate = ev.currentTarget.getAttribute('data-gate');
    if (!currentGate) {
        ev.currentTarget.style.background = '';
    }
    
    const gate = ev.dataTransfer.getData("text");
    const td = ev.target.closest('td');
    if (!td) return;
    
    const row = td.parentElement.rowIndex;
    const col = td.cellIndex;
    
    td.style.transform = 'scale(1.1)';
    setTimeout(() => {
        td.style.transform = '';
    }, 200);

    if (gate === "C") {
        // CNOT門需要選擇控制位和目標位
        const controlQubit = prompt("請選擇控制位 (0-" + (+document.getElementById("numQubits").value - 1) + "):");
        const targetQubit = prompt("請選擇目標位 (0-" + (+document.getElementById("numQubits").value - 1) + "):");
        
        if (controlQubit === null || targetQubit === null || 
            controlQubit === targetQubit || 
            isNaN(controlQubit) || isNaN(targetQubit) ||
            controlQubit < 0 || targetQubit < 0 ||
            controlQubit >= +document.getElementById("numQubits").value ||
            targetQubit >= +document.getElementById("numQubits").value) {
            return; // 取消或輸入無效
        }
        
        // 設置CNOT門占據兩個格子
        setCNOTGate(col, parseInt(controlQubit), parseInt(targetQubit));
    } else if (gate === "D") {
        // Toffoli門需要選擇兩個控制位和一個目標位
        const numQubits = +document.getElementById("numQubits").value;
        const control1Qubit = prompt("請選擇第一個控制位 (0-" + (numQubits - 1) + "):");
        const control2Qubit = prompt("請選擇第二個控制位 (0-" + (numQubits - 1) + "):");
        const targetQubit = prompt("請選擇目標位 (0-" + (numQubits - 1) + "):");
        
        if (control1Qubit === null || control2Qubit === null || targetQubit === null || 
            control1Qubit === control2Qubit || control1Qubit === targetQubit || control2Qubit === targetQubit ||
            isNaN(control1Qubit) || isNaN(control2Qubit) || isNaN(targetQubit) ||
            control1Qubit < 0 || control2Qubit < 0 || targetQubit < 0 ||
            control1Qubit >= numQubits || control2Qubit >= numQubits || targetQubit >= numQubits) {
            return; // 取消或輸入無效
        }
        
        // 設置Toffoli門占據三個格子
        setToffoliGate(col, parseInt(control1Qubit), parseInt(control2Qubit), parseInt(targetQubit));
    } else {
        td.textContent = gate;
        td.setAttribute("data-gate", gate);
    }
    simulate();
}

function clearGate(ev) {
    if (ev.target.tagName === "SELECT" || ev.target.tagName === "OPTION") return;
    
    const td = ev.currentTarget;
    td.style.transform = 'scale(0.9)';
    setTimeout(() => {
        td.style.transform = '';
    }, 150);
    
    // 如果是CNOT門，需要特殊處理
    if (td.getAttribute("data-gate") === "C" && td.hasAttribute("data-cnot-role")) {
        clearCNOTGate(td);
    } else if (td.getAttribute("data-gate") === "D" && td.hasAttribute("data-toffoli-role")) {
        // 如果是Toffoli門，需要特殊處理
        clearToffoliGate(td);
    } else {
        // 普通門的清除
        td.textContent = "";
        td.setAttribute("data-gate", "");
        td.removeAttribute("data-col");
        
        // 清除可能的量子門相關樣式
        td.classList.remove('cnot-control', 'cnot-target', 'toffoli-control1', 'toffoli-control2', 'toffoli-target');
    }
    
    simulate();
    
    // 重整畫布
    if (typeof resetCanvas === 'function') {
        resetCanvas();
    }
}

function makeQubitOptions() {
    const nq = +document.getElementById("numQubits").value;
    return Array.from({length: nq}, (_, i) => `<option value='${i}'>q${i}</option>`).join('');
}

function setCNOTGate(col, controlQubit, targetQubit) {
    const table = document.getElementById("circuitTable");
    const rows = table.querySelectorAll('tr');
    
    // 檢查指定位置是否已經有門
    if (rows[controlQubit] && rows[controlQubit].cells[col] && 
        rows[controlQubit].cells[col].getAttribute('data-gate') !== '') {
        alert(`位置 (q${controlQubit}, col${col}) 已經有量子門！`);
        return;
    }
    
    if (rows[targetQubit] && rows[targetQubit].cells[col] && 
        rows[targetQubit].cells[col].getAttribute('data-gate') !== '') {
        alert(`位置 (q${targetQubit}, col${col}) 已經有量子門！`);
        return;
    }
    
    // 設置控制位格子
    if (rows[controlQubit] && rows[controlQubit].cells[col]) {
        const controlCell = rows[controlQubit].cells[col];
        controlCell.classList.add('cnot-control');
        controlCell.setAttribute('data-gate', 'C');
        controlCell.setAttribute('data-cnot-role', 'control');
        controlCell.setAttribute('data-cnot-partner', targetQubit);
        controlCell.setAttribute('data-cnot-col', col);
        controlCell.textContent = '●';
        controlCell.title = `CNOT控制位 → q${targetQubit}`;
    }
    
    // 設置目標位格子
    if (rows[targetQubit] && rows[targetQubit].cells[col]) {
        const targetCell = rows[targetQubit].cells[col];
        targetCell.classList.add('cnot-target');
        targetCell.setAttribute('data-gate', 'C');
        targetCell.setAttribute('data-cnot-role', 'target');
        targetCell.setAttribute('data-cnot-partner', controlQubit);
        targetCell.setAttribute('data-cnot-col', col);
        targetCell.textContent = '⊕';
        targetCell.title = `CNOT目標位 ← q${controlQubit}`;
    }
    
    simulate();
}

function clearCNOTGate(cell) {
    const col = parseInt(cell.getAttribute('data-cnot-col'));
    const partner = parseInt(cell.getAttribute('data-cnot-partner'));
    const table = document.getElementById("circuitTable");
    const rows = table.querySelectorAll('tr');
    
    // 清除當前格子
    cell.classList.remove('cnot-control', 'cnot-target');
    cell.textContent = '';
    cell.setAttribute('data-gate', '');
    cell.removeAttribute('data-cnot-role');
    cell.removeAttribute('data-cnot-partner');
    cell.removeAttribute('data-cnot-col');
    cell.title = '';
    
    // 清除夥伴格子
    if (rows[partner] && rows[partner].cells[col]) {
        const partnerCell = rows[partner].cells[col];
        partnerCell.classList.remove('cnot-control', 'cnot-target');
        partnerCell.textContent = '';
        partnerCell.setAttribute('data-gate', '');
        partnerCell.removeAttribute('data-cnot-role');
        partnerCell.removeAttribute('data-cnot-partner');
        partnerCell.removeAttribute('data-cnot-col');
        partnerCell.title = '';
    }
    
    // 重整畫布
    if (typeof resetCanvas === 'function') {
        resetCanvas();
    }
}

function setToffoliGate(col, control1Qubit, control2Qubit, targetQubit) {
    const table = document.getElementById("circuitTable");
    const rows = table.querySelectorAll('tr');
    
    // 檢查指定位置是否已經有門
    const positions = [control1Qubit, control2Qubit, targetQubit];
    for (const pos of positions) {
        if (rows[pos] && rows[pos].cells[col] && 
            rows[pos].cells[col].getAttribute('data-gate') !== '') {
            alert(`位置 (q${pos}, col${col}) 已經有量子門！`);
            return;
        }
    }
    
    // 設置第一個控制位格子
    if (rows[control1Qubit] && rows[control1Qubit].cells[col]) {
        const control1Cell = rows[control1Qubit].cells[col];
        control1Cell.classList.add('toffoli-control1');
        control1Cell.setAttribute('data-gate', 'D');
        control1Cell.setAttribute('data-toffoli-role', 'control1');
        control1Cell.setAttribute('data-toffoli-control1', control1Qubit);
        control1Cell.setAttribute('data-toffoli-control2', control2Qubit);
        control1Cell.setAttribute('data-toffoli-target', targetQubit);
        control1Cell.setAttribute('data-toffoli-col', col);
        control1Cell.textContent = '●';
        control1Cell.title = `Toffoli控制位1 → q${targetQubit} (與q${control2Qubit})`;
    }
    
    // 設置第二個控制位格子
    if (rows[control2Qubit] && rows[control2Qubit].cells[col]) {
        const control2Cell = rows[control2Qubit].cells[col];
        control2Cell.classList.add('toffoli-control2');
        control2Cell.setAttribute('data-gate', 'D');
        control2Cell.setAttribute('data-toffoli-role', 'control2');
        control2Cell.setAttribute('data-toffoli-control1', control1Qubit);
        control2Cell.setAttribute('data-toffoli-control2', control2Qubit);
        control2Cell.setAttribute('data-toffoli-target', targetQubit);
        control2Cell.setAttribute('data-toffoli-col', col);
        control2Cell.textContent = '●';
        control2Cell.title = `Toffoli控制位2 → q${targetQubit} (與q${control1Qubit})`;
    }
    
    // 設置目標位格子
    if (rows[targetQubit] && rows[targetQubit].cells[col]) {
        const targetCell = rows[targetQubit].cells[col];
        targetCell.classList.add('toffoli-target');
        targetCell.setAttribute('data-gate', 'D');
        targetCell.setAttribute('data-toffoli-role', 'target');
        targetCell.setAttribute('data-toffoli-control1', control1Qubit);
        targetCell.setAttribute('data-toffoli-control2', control2Qubit);
        targetCell.setAttribute('data-toffoli-col', col);
        targetCell.textContent = '⊕';
        targetCell.title = `Toffoli目標位 ← q${control1Qubit} & q${control2Qubit}`;
    }
    
    simulate();
}

function clearToffoliGate(cell) {
    const col = parseInt(cell.getAttribute('data-toffoli-col'));
    const table = document.getElementById("circuitTable");
    const rows = table.querySelectorAll('tr');
    
    // 在同一列中找到所有屬於Toffoli門的格子
    for (let r = 0; r < rows.length; r++) {
        const currentCell = rows[r].cells[col];
        if (currentCell && 
            currentCell.getAttribute('data-gate') === 'D' && 
            currentCell.hasAttribute('data-toffoli-role') &&
            parseInt(currentCell.getAttribute('data-toffoli-col')) === col) {
            
            // 清除這個格子
            currentCell.classList.remove('toffoli-control1', 'toffoli-control2', 'toffoli-target');
            currentCell.textContent = '';
            currentCell.setAttribute('data-gate', '');
            currentCell.removeAttribute('data-toffoli-role');
            currentCell.removeAttribute('data-toffoli-control1');
            currentCell.removeAttribute('data-toffoli-control2');
            currentCell.removeAttribute('data-toffoli-target');
            currentCell.removeAttribute('data-toffoli-col');
            currentCell.title = '';
        }
    }
    
    // 重整畫布
    if (typeof resetCanvas === 'function') {
        resetCanvas();
    }
}

function clearAllGates() {
    const table = document.getElementById("circuitTable");
    if (!table || !table.rows.length) return;
    
    // 檢查是否有門需要清除
    let hasGates = false;
    for (let r = 0; r < table.rows.length; r++) {
        const row = table.rows[r];
        for (let c = 0; c < row.cells.length; c++) {
            const cell = row.cells[c];
            if (cell.getAttribute('data-gate') && cell.getAttribute('data-gate') !== '') {
                hasGates = true;
                break;
            }
        }
        if (hasGates) break;
    }
    
    if (!hasGates) {
        alert('電路中沒有量子門需要清除。');
        return;
    }
    
    // 確認操作
    if (!confirm('確定要清除電路中的所有量子門嗎？此操作無法復原。')) {
        return;
    }
    
    // 添加視覺反饋
    const button = event.target;
    const originalText = button.textContent;
    button.textContent = '清除中...';
    button.disabled = true;
    
    // 遍歷所有格子並清除門
    let clearedCount = 0;
    for (let r = 0; r < table.rows.length; r++) {
        const row = table.rows[r];
        for (let c = 0; c < row.cells.length; c++) {
            const cell = row.cells[c];
            
            // 檢查是否有門需要清除
            if (cell.getAttribute('data-gate') && cell.getAttribute('data-gate') !== '') {
                clearedCount++;
                
                // 添加清除動畫效果
                cell.style.transform = 'scale(0.8)';
                cell.style.opacity = '0.5';
                
                setTimeout(() => {
                    // 清除所有門相關的屬性和樣式
                    cell.textContent = '';
                    cell.setAttribute('data-gate', '');
                    cell.removeAttribute('data-col');
                    
                    // 清除CNOT門相關屬性
                    cell.removeAttribute('data-cnot-role');
                    cell.removeAttribute('data-cnot-partner');
                    cell.removeAttribute('data-cnot-col');
                    
                    // 清除Toffoli門相關屬性
                    cell.removeAttribute('data-toffoli-role');
                    cell.removeAttribute('data-toffoli-control1');
                    cell.removeAttribute('data-toffoli-control2');
                    cell.removeAttribute('data-toffoli-target');
                    cell.removeAttribute('data-toffoli-col');
                    
                    // 清除所有量子門樣式類
                    cell.classList.remove('cnot-control', 'cnot-target', 'toffoli-control1', 'toffoli-control2', 'toffoli-target');
                    
                    // 清除title屬性
                    cell.title = '';
                    
                    // 重置背景樣式
                    cell.style.background = '';
                    
                    // 恢復正常樣式
                    cell.style.transform = '';
                    cell.style.opacity = '';
                }, 100 + (r * 50) + (c * 20)); // 錯開動畫時間
            }
        }
    }
    
    // 延遲執行模擬和重整，等待動畫完成
    setTimeout(() => {
        // 重新模擬量子電路（現在是空電路）
        simulate();
        
        // 重整畫布
        if (typeof resetCanvas === 'function') {
            resetCanvas();
        }
        
        // 恢復按鈕狀態
        button.textContent = originalText;
        button.disabled = false;
        
        console.log(`已清除 ${clearedCount} 個量子門`);
        
        // 顯示成功訊息
        const output = document.getElementById('output');
        if (output) {
            output.textContent = `已清除 ${clearedCount} 個量子門，電路已重置為初始態 |000...⟩`;
        }
    }, 500);
}

function renderCircuit() {
    const nq = +document.getElementById("numQubits").value;
    const nc = +document.getElementById("numCols").value;
    const table = document.getElementById("circuitTable");
    const labels = document.getElementById("qubitLabels");
    
    table.innerHTML = "";
    labels.innerHTML = "";
    
    for (let r = 0; r < nq; r++) {
        const label = document.createElement("div");
        label.className = "qubit-label";
        label.textContent = `|q${r}⟩`;
        labels.appendChild(label);
    }
    
    for (let r = 0; r < nq; r++) {
        const row = document.createElement("tr");
        for (let c = 0; c < nc; c++) {
            const cell = document.createElement("td");
            cell.setAttribute("data-gate", "");
            cell.ondrop = drop;
            cell.ondragover = allowDrop;
            cell.ondragleave = handleDragLeave;
            cell.onclick = clearGate;
            row.appendChild(cell);
        }
        table.appendChild(row);
    }
    

    
    simulate();
}

// 量子運算
const H = [[1/Math.sqrt(2),1/Math.sqrt(2)],[1/Math.sqrt(2),-1/Math.sqrt(2)]];
const X = [[0,1],[1,0]];
const Y = [[0, math.complex(0, -1)],[math.complex(0, 1), 0]];
const Z = [[1,0],[0,-1]];
const S = [[1,0],[0, math.complex(0, 1)]]; // Phase gate (S gate)
const I = [[1,0],[0,1]];

function kron(a, b) {
    const result = [];
    for (let i = 0; i < a.length; i++) {
        for (let j = 0; j < b.length; j++) {
            result.push(a[i].map(x => b[j].map(y => math.multiply(x, y))).flat());
        }
    }
    return result;
}

function applyGate(state, matrix) {
    const res = Array(state.length).fill(0).map(_ => math.complex(0, 0));
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix.length; j++) {
            res[i] = math.add(res[i], math.multiply(matrix[i][j], state[j]));
        }
    }
    return res;
}

function createCNOT(n, control, target) {
    const size = 1 << n;
    const mat = Array.from({ length: size }, () => Array(size).fill(math.complex(0, 0)));
    for (let i = 0; i < size; i++) {
        const bit = (i >> (n - 1 - control)) & 1;
        let j = i;
        if (bit) j ^= (1 << (n - 1 - target));
        mat[j][i] = math.complex(1, 0);
    }
    return mat;
}

function createToffoli(n, c1, c2, target) {
    const size = 1 << n;
    const mat = Array.from({ length: size }, () => Array(size).fill(math.complex(0, 0)));
    for (let i = 0; i < size; i++) {
        const b1 = (i >> (n - 1 - c1)) & 1;
        const b2 = (i >> (n - 1 - c2)) & 1;
        let j = i;
        if (b1 && b2) j ^= (1 << (n - 1 - target));
        mat[j][i] = math.complex(1, 0);
    }
    return mat;
}

function mapQuantumStateToParameters(state, numQubits) {
    const nonZeroStates = [];
    const amplitudes = [];
    
    for (let i = 0; i < state.length; i++) {
        const amplitude = math.abs(state[i]);
        if (amplitude > 1e-6) {
            const bin = i.toString(2).padStart(numQubits, '0');
            nonZeroStates.push({
                state: bin,
                amplitude: amplitude,
                complex: state[i],
                index: i
            });
            amplitudes.push(amplitude);
        }
    }
    
    if (nonZeroStates.length === 0) return;
    
    // 使用量子態振幅來映射到參數
    const totalAmplitude = amplitudes.reduce((sum, amp) => sum + amp, 0);
    const weightedSum = nonZeroStates.reduce((sum, s) => sum + s.amplitude * s.index, 0);
    const maxIndex = Math.max(...nonZeroStates.map(s => s.index));
    
    // 映射邏輯：將量子態的特性轉換為繪畫參數，並記錄計算來源
    quantumParameters.particleCount = Math.floor(500 + (weightedSum / totalAmplitude) * 700);
    parameterSources.particleCount = `加權和(${weightedSum.toFixed(3)}) / 總振幅(${totalAmplitude.toFixed(3)})`;
    
    quantumParameters.particleSize = Math.floor(20 + (amplitudes[0] || 0) * 80);
    parameterSources.particleSize = `第一態振幅: ${(amplitudes[0] || 0).toFixed(3)} (|${nonZeroStates[0]?.state || '000'}⟩)`;
    
    quantumParameters.randomColor = 50;
    
    // 使用HSV色彩空間來控制主色調
    const firstAmplitude = amplitudes[0] || 0;
    const secondAmplitude = amplitudes[1] || 0;
    const firstComplex = nonZeroStates[0]?.complex || math.complex(0, 0);
    
    // 計算HSV值
    // H (色調): 使用第一個量子態的相位角度 (0-360度)
    const phase = math.arg(firstComplex); // 相位角度 (-π 到 π)
    const hue = ((phase + Math.PI) / (2 * Math.PI)) * 360; // 轉換到0-360度
    
    // S (飽和度): 使用第一個量子態的振幅 (0-1)
    const saturation = firstAmplitude;
    
    // V (明度): 使用第二個量子態的振幅，如果沒有第二態則使用0.8
    const value = nonZeroStates[1] ? secondAmplitude : 0.8;
    
    // 將HSV轉換為RGB
    const rgb = hsvToRgb(hue, saturation, value);
    
    quantumParameters.mainRed = Math.floor(rgb.r);
    quantumParameters.mainGreen = Math.floor(rgb.g);
    quantumParameters.mainBlue = Math.floor(rgb.b);
    
    parameterSources.mainRed = `HSV轉RGB - H:${hue.toFixed(1)}° S:${saturation.toFixed(3)} V:${value.toFixed(3)}`;
    parameterSources.mainGreen = `色調來自第一態相位: ${phase.toFixed(3)}rad (|${nonZeroStates[0]?.state || '000'}⟩)`;
    parameterSources.mainBlue = nonZeroStates[1] ? 
        `飽和度=${saturation.toFixed(3)}, 明度來自第二態: ${value.toFixed(3)} (|${nonZeroStates[1].state}⟩)` : 
        `飽和度=${saturation.toFixed(3)}, 明度預設: ${value.toFixed(3)}`;
    
    quantumParameters.colorVariation = Math.floor(nonZeroStates.length * 10);
    parameterSources.colorVariation = `非零態數量: ${nonZeroStates.length}`;
    
    quantumParameters.decayRate = 0.95 + (amplitudes[0] || 0) * 0.04;
    parameterSources.decayRate = `0.95 + 第一態振幅(${(amplitudes[0] || 0).toFixed(3)}) × 0.04`;
    
    // 使用第一態和第二態振幅的乘積控制旋轉因子
    quantumParameters.rotationFactor = nonZeroStates[1] ? 
        (firstAmplitude * secondAmplitude) * 0.01 :
        (firstAmplitude * firstAmplitude) * 0.01;
    parameterSources.rotationFactor = nonZeroStates[1] ? 
        `第一態振幅(${firstAmplitude.toFixed(3)}) × 第二態振幅(${secondAmplitude.toFixed(3)}) × 0.01` :
        `僅一個非零態，使用振幅平方: ${firstAmplitude.toFixed(3)}² × 0.01`;
    
    // 使用不同量子態控制陰影
    if (nonZeroStates.length > 1) {
        const shadowRealPart = math.re(nonZeroStates[1].complex);
        const shadowImagPart = math.im(nonZeroStates[1].complex);
        
        quantumParameters.shadowX = Math.abs(shadowRealPart) * 10;
        parameterSources.shadowX = `第二態實部絕對值: ${Math.abs(shadowRealPart).toFixed(3)} (|${nonZeroStates[1].state}⟩)`;
        
        quantumParameters.shadowY = Math.abs(shadowImagPart) * 10;
        parameterSources.shadowY = `第二態虛部絕對值: ${Math.abs(shadowImagPart).toFixed(3)} (|${nonZeroStates[1].state}⟩)`;
    } else {
        parameterSources.shadowX = "僅一個非零態，使用預設值";
        parameterSources.shadowY = "僅一個非零態，使用預設值";
    }
    
    // 背景顏色基於總體量子態分佈
    const entropy = -nonZeroStates.reduce((sum, s) => {
        const p = s.amplitude / totalAmplitude;
        return sum + p * Math.log2(p);
    }, 0);
    
    quantumParameters.bgRed = Math.floor(200 + entropy * 10);
    quantumParameters.bgGreen = Math.floor(200 + entropy * 10);
    quantumParameters.bgBlue = Math.floor(200 + entropy * 10);
    parameterSources.bgRed = `熵值: ${entropy.toFixed(3)}`;
    parameterSources.bgGreen = `熵值: ${entropy.toFixed(3)}`;
    parameterSources.bgBlue = `熵值: ${entropy.toFixed(3)}`;
    
    // 更新顯示
    updateParameterDisplay();
    
    // 重新生成粒子
    if (typeof resetCanvas === 'function') {
        resetCanvas();
    }
}

// HSV到RGB的轉換函數
function hsvToRgb(h, s, v) {
    h = h / 60; // 將色調轉換到0-6範圍
    const c = v * s; // 彩度
    const x = c * (1 - Math.abs((h % 2) - 1));
    const m = v - c;
    
    let r, g, b;
    
    if (h >= 0 && h < 1) {
        r = c; g = x; b = 0;
    } else if (h >= 1 && h < 2) {
        r = x; g = c; b = 0;
    } else if (h >= 2 && h < 3) {
        r = 0; g = c; b = x;
    } else if (h >= 3 && h < 4) {
        r = 0; g = x; b = c;
    } else if (h >= 4 && h < 5) {
        r = x; g = 0; b = c;
    } else {
        r = c; g = 0; b = x;
    }
    
    return {
        r: Math.round((r + m) * 255),
        g: Math.round((g + m) * 255),
        b: Math.round((b + m) * 255)
    };
}

function updateParameterDisplay() {
    document.getElementById('particleCountDisplay').textContent = quantumParameters.particleCount;
    document.getElementById('particleSizeDisplay').textContent = quantumParameters.particleSize;
    document.getElementById('mainColorDisplay').textContent = `(${quantumParameters.mainRed}, ${quantumParameters.mainGreen}, ${quantumParameters.mainBlue})`;
    document.getElementById('colorVariationDisplay').textContent = quantumParameters.colorVariation;
    document.getElementById('decayRateDisplay').textContent = quantumParameters.decayRate.toFixed(4);
    document.getElementById('rotationFactorDisplay').textContent = quantumParameters.rotationFactor.toFixed(4);
    document.getElementById('shadowOffsetDisplay').textContent = `(${quantumParameters.shadowX.toFixed(1)}, ${quantumParameters.shadowY.toFixed(1)})`;
    document.getElementById('bgColorDisplay').textContent = `(${quantumParameters.bgRed}, ${quantumParameters.bgGreen}, ${quantumParameters.bgBlue})`;
    
    // 更新參數來源顯示
    document.getElementById('particleCountSource').textContent = parameterSources.particleCount;
    document.getElementById('particleSizeSource').textContent = parameterSources.particleSize;
    document.getElementById('mainColorSource').textContent = `R: ${parameterSources.mainRed} | G: ${parameterSources.mainGreen} | B: ${parameterSources.mainBlue}`;
    document.getElementById('colorVariationSource').textContent = parameterSources.colorVariation;
    document.getElementById('decayRateSource').textContent = parameterSources.decayRate;
    document.getElementById('rotationFactorSource').textContent = parameterSources.rotationFactor;
    document.getElementById('shadowOffsetSource').textContent = `X: ${parameterSources.shadowX} | Y: ${parameterSources.shadowY}`;
    document.getElementById('bgColorSource').textContent = parameterSources.bgRed;
}

function simulate() {
    const nq = +document.getElementById("numQubits").value;
    const table = document.getElementById("circuitTable");
    if (!table.rows.length) return;
    
    const nc = table.rows[0].cells.length;
    let state = Array(1 << nq).fill(math.complex(0, 0));
    state[0] = math.complex(1, 0);

    for (let c = 0; c < nc; c++) {
        let hasCNOT = false;
        let processedCNOT = new Set(); // 避免重複處理同一個CNOT門
        let processedToffoli = new Set(); // 避免重複處理同一個Toffoli門
        
        for (let r = 0; r < nq; r++) {
            const cell = table.rows[r].cells[c];
            const g = cell.getAttribute("data-gate") || "I";
            if (g === "C" && cell.hasAttribute("data-cnot-role")) {
                const cnotCol = cell.getAttribute("data-cnot-col");
                const role = cell.getAttribute("data-cnot-role");
                const partner = parseInt(cell.getAttribute("data-cnot-partner"));
                
                // 只在控制位處理CNOT門，避免重複
                if (role === "control" && !processedCNOT.has(`${cnotCol}-${r}-${partner}`)) {
                    const control = r;
                    const target = partner;
                    const U = createCNOT(nq, control, target);
                    state = applyGate(state, U);
                    hasCNOT = true;
                    processedCNOT.add(`${cnotCol}-${r}-${partner}`);
                }
            } else if (g === "D" && cell.hasAttribute("data-toffoli-role")) {
                const toffoliCol = cell.getAttribute("data-toffoli-col");
                const role = cell.getAttribute("data-toffoli-role");
                const control1 = parseInt(cell.getAttribute("data-toffoli-control1"));
                const control2 = parseInt(cell.getAttribute("data-toffoli-control2"));
                const target = parseInt(cell.getAttribute("data-toffoli-target"));
                
                // 只在第一個控制位處理Toffoli門，避免重複
                if (role === "control1" && !processedToffoli.has(`${toffoliCol}-${control1}-${control2}-${target}`)) {
                    console.log(`處理Toffoli門: 控制位1=${control1}, 控制位2=${control2}, 目標位=${target}`);
                    const toffoliMatrix = createToffoli(nq, control1, control2, target);
                    state = math.multiply(toffoliMatrix, state);
                    hasCNOT = true;
                    processedToffoli.add(`${toffoliCol}-${control1}-${control2}-${target}`);
                }
            }
        }
        if (!hasCNOT) {
            const gates = [];
            for (let r = 0; r < nq; r++) {
                const cell = table.rows[r].cells[c];
                const g = cell.getAttribute("data-gate") || "I";
                // 跳過CNOT門和Toffoli門的格子，因為它們已經在上面處理過了
                if ((g === "C" && cell.hasAttribute("data-cnot-role")) || 
                    (g === "D" && cell.hasAttribute("data-toffoli-role"))) {
                    gates.push(I); // 多位門的格子用單位矩陣
                } else {
                    gates.push(({ H, X, Y, Z, S, I })[g] || I);
                }
            }
            const U = gates.reduce((a, b) => kron(a, b));
            state = applyGate(state, U);
        }
    }

    let out = "";
    const nonZeroStates = [];
    for (let i = 0; i < state.length; i++) {
        if (math.abs(state[i]) > 1e-6) {
            const bin = i.toString(2).padStart(nq, '0');
            nonZeroStates.push(`${state[i].toString()} |${bin}⟩`);
        }
    }
    
    if (nonZeroStates.length > 0) {
        out = nonZeroStates.join('\n');
    } else {
        out = "沒有找到顯著的振幅態。";
    }
    
    document.getElementById("output").textContent = out;
    
    // 將量子態映射到繪畫參數
    mapQuantumStateToParameters(state, nq);
}

let themes = [
	"d72638-3f88c5-f49d37-140f2d-f22b29-fe4a49-fed766-7fbb8f-009fb7-e6e6ea-fff-102a54".split("-").map(a=>"#"+a),
	"584d3d-9f956c-cbbf7a-f4e87c-ebf38b-fed766-fff-ffa856-000-e5dede".split("-").map(a=>"#"+a)	,
	"0e131f-38405f-59546c-8b939c-ff0035-2c0735-fff".split("-").map(a=>"#"+a),
	
	// "ffc854-000-ffc854-000-fff".split("-").map(a=>"#"+a),
	// "261447-f1e3f3-c2bbf0-8fb8ed-62bfed-3590f3-fff-FF8680".split("-").map(a=>"#"+a),
	// "07252F-7c6a0a-babd8d-ffdac6-fa9500-eb6424-FCFBF6".split("-").map(a=>"#"+a),
	// "e6e1c6-afac96-c0bda5-cc978e-f39c6b-f96a68-ff3864-261447-3a2958-fff".split("-").map(a=>"#"+a),
	// "0a369d-4472ca-5e7ce2-92b4f4-cfdee7-fff".split("-").map(a=>"#"+a),	
	// "daddd8-c7d59f-b7ce63-8fb339-4b5842-fafafa-daddd8-c7d59f-b7ce63-8fb339-4b5842-fafafa-daddd8-c7d59f-b7ce63-8fb339-4b5842-fafafa-FF715B".split("-").map(a=>"#"+a)
]
// // "000-aaa-fff-eee".split("-").map(a=>"#"+a),
//"fff-9fa2b2-3c7a89-2e4756-16262e-000-fff-9fa2b2-3c7a89-2e4756-16262e-000-fff".split("-").map(a=>"#"+a),

let features = {}
let colors
let defaultSize = 1080

//001427
//p5.js shader basic structure ref from https://www.openprocessing.org/sketch/920144

class Wormhole{
	constructor (args){
		let def = {
			p: createVector(0,0),
			intensity: random([-5,5]),
			r: 500,
			rotate: 1,
			attract: 1
		}
		Object.assign(def,args)
		Object.assign(this,def)
	}
	update(){
	}
}
class Particle{
	constructor(args){
		let def = {
			position: createVector(0,0),
			lastPosition: createVector(-1,-1),
			velocity: createVector(0,0),
			acceleration: createVector(0,0),
			radius: random(100),
			rotationFactor: quantumParameters.rotationFactor,
			particleColor: random(colors),
			movementSteps: [int(random([2,3,10,20,30,50,120,150])),int(random([2,3,4]))],
			decayRate: quantumParameters.decayRate,
			noiseScale: features.vNoiseScale,
			secondaryColor: random([255,255,random(colors)]),
			uniqueId: int(random(10000)),
			horizontalSpeed: random([6,8,10,12]),
			verticalSpeed: random([6,8,10,12]),
			shadowDisplacement: createVector(
				quantumParameters.shadowX,
				quantumParameters.shadowY
			),
			colorVariation: quantumParameters.colorVariation
		}
		Object.assign(def,args)
		Object.assign(this,def)
	}
	draw(g){
		g.push()
			// g.blendMode(MULTIPLY)
			let clr = color(this.particleColor)
// 			clr.setAlpha(500*map(this.r,200,0,0.02,0,true))
// 			let colorVar = 30
// 			clr.setRed(clr._getRed()+noise(this.p.x/5,this.p.y/5)*colorVar-colorVar/2)
// 			clr.setGreen(clr._getGreen()+noise(1000,this.p.x/5,this.p.y/5)*colorVar-colorVar/2)
// 			clr.setBlue(clr._getBlue()+noise(this.p.x/5,1000,this.p.y/5)*colorVar-colorVar/2)
		 
			
// 			if (
// 			g.stroke(clr)
// 			g.blendMode(MULTIPLY)
// 			if (frameCount>10) return
// 			g.noFill()
			g.fill(clr)
		 
			if (noise(this.position.x/50,this.position.y/50)<0.3 && random()<0.35 && features.style=="stroke"){
				overlayGraphics.push()
					overlayGraphics.noStroke()
					overlayGraphics.fill(clr)
					overlayGraphics.ellipse(this.position.x+random(-this.radius,this.radius),this.position.y+random(-this.radius,this.radius),random(6)*random()*random(0.5,1))
				overlayGraphics.pop()
			}
			g.translate(this.position)
		// g.noStroke()
			if (frameCount==1 && this.uniqueId%5==0){
				g.strokeWeight(2)
				g.stroke(this.secondaryColor)
			}
		
			//test stroke style
			if (features.style=="stroke" ){
				//mountain lines
				if ( (this.uniqueId+frameCount)%5==0){
					g.push()
							g.blendMode(MULTIPLY)
							clr.setAlpha(noise(this.uniqueId)*150)
							g.translate(-this.position.x,-this.position.y)
							let rr = noise(this.uniqueId)*5*noise(this.uniqueId)
							g.stroke(clr)
							g.strokeWeight(rr)
							if (this.lastPosition.x!=-1){
								// console.log(this.p,this.lastP)
								
								g.line(this.position.x,this.position.y,this.lastPosition.x,this.lastPosition.y)
							}
							this.lastPosition = this.position.copy()
					g.pop()
				}
				if ((this.uniqueId+frameCount)%8==0 && this.uniqueId%(9 + int(50/pow(this.radius/10,3)))<=1){ 
					g.push()
					
						g.blendMode(MULTIPLY)
						// g.fill(clr)
						// g.noStroke()
					
					
					
						clr.setAlpha(random(255))
						g.stroke(clr)
						// if((this.uniqueId+frameCount)%3==0){
						// 	g.blendMode(MULTIPLY)
						// }
					
						g.strokeWeight(noise(this.position.x/40,this.position.y/40)*2.5*random(0.3,1))
						g.rotate(noise(this.position.x/100,this.position.y/100,this.uniqueId)*PI*2)
						g.rotate(noise(this.position.x/5,this.position.y/5,this.uniqueId)/2)
						if (this.uniqueId%4==0 && brightness(clr)>50){
							clr.setAlpha(random(8))
							g.fill(clr)
							clr.setAlpha(random(150))
							g.stroke(clr)
							if (random()<0.9){
								g.noStroke()
							}
							let waterColorScale = noise(this.uniqueId,1000)*5+1
							g.arc(0,0,this.radius*waterColorScale,this.radius*waterColorScale,0,PI)
						}else{
							g.line(0,this.radius/2,this.radius,-this.radius/2)
						}
					
					
					
					g.pop()
				}else{
					if ((this.uniqueId+frameCount)%10==0){
// 						g.push()
// 						clr.setAlpha(5)
// 						g.fill(clr)
						
// 						g.blendMode(MULTIPLY)
// 						g.ellipse(0,0,this.r,this.r)
// 					g.pop()
					}
				}
			}
			if (features.style=="shape" || features.style=="stroke"){
				if (features.style=="shape" || noise(this.position.x/52,this.position.y/52)<0.525){
					if (frameCount%40==0){
						clr.setAlpha(random(0,1))
						g.fill(clr)
						g.ellipse(0,0,this.radius,this.radius)

					}else if ((this.uniqueId+frameCount)%8==0 && this.uniqueId%(9 + int(50/pow(this.radius/10,3)))<=1){

						g.noFill() 
						clr.setAlpha(random(200,255))
						g.stroke(clr)
						g.strokeWeight(random(0,2)*random(0.5,1))
						
						if (this.uniqueId%88==0 && random()<0.2){
							clr.setAlpha(random(100,200))
							g.strokeWeight(noise(this.uniqueId*500)*8)
						}

						
						g.blendMode(MULTIPLY)	
						if (brightness(clr)>90){
							if (random()<0.5){
								g.blendMode(SCREEN)
							}
						}

						if (this.uniqueId%2==0 && frameCount%2==0){
							clr.setAlpha(random(0,1))
							g.fill(clr)
							g.noStroke()
						}
						if (this.uniqueId%10==0 || noise(this.position.x/120,this.position.y/120)<=0.3){
							//draw a line
							g.rotate(noise(this.position.x*5,this.position.y*5,frameCount/10)*PI*2 )
							g.line(0,this.radius,0,-this.radius)
						}else{
							if (this.uniqueId% 3==0  ){
								clr.setAlpha(random(0,3))
								g.fill(clr)
							}
							//draw an ellipse
							g.ellipse(0,0,this.radius*1.1,this.radius*1.1)
						}
					}
				}
			}else if (features.style=="normal"){ 
					//fill 
				g.ellipse(0,0,this.radius,this.radius)  
				
				
				// if (noise(this.p.x/300,this.p.y/300)<0.3 && random()<0.02){
				// 	overlayGraphics.push()
				// 		overlayGraphics.noStroke()
				// 		overlayGraphics.fill(clr)
				// 		overlayGraphics.rect(this.p.x+random(-this.r,this.r),this.p.y+random(-this.r,this.r),20,-20,10)
				// 	overlayGraphics.pop()
				// }
			}
		
		
		// g.ellipse(this.r*2+10,0,3,3)
		
			//grass
			if (this.uniqueId%30==0 && frameCount%50==0 && this.radius>1){
				
				// g.fill(bgColor)
				g.push()
				g.translate(this.radius+20,0)
				g.stroke(this.secondaryColor)
				g.translate(0,random([-this.radius,this.radius]))
				g.line(0,0,0,-5)
				g.line(0,0,-3,-5)
				g.line(0,0,3,-5)
				g.pop()
			}
	
		let verticalLineSpan = 5
		if (features.style=="shape") verticalLineSpan = 30
		
		if (features.style=="stroke") verticalLineSpan = 35
			// vertical lines
			if (this.uniqueId%verticalLineSpan==0){
				g.fill(0)
				g.ellipse(0,this.radius+10,2,2)
			}
		
			if (this.uniqueId%10==0){
				
				g.fill(bgColor)
				g.ellipse(this.radius/2,0,2,2)
			}
			if (this.uniqueId%25==0){
				
				g.fill(255)
				let whiteR = (noise(this.uniqueId,this.position.x/40,this.position.y/40)*3)+1
				g.ellipse(-this.radius-10,this.radius+10,whiteR,whiteR)
			}
			if (this.radius>10 && (this.uniqueId+frameCount)%60==0 && this.uniqueId%4==0){
				g.fill(this.secondaryColor)
				g.ellipse(-this.radius,4,4)
			} 
			if (features.style=='normal' && frameCount%50==0 && this.uniqueId%14==0 && random()<0.6){
				g.push()
				let lineSp = random([5,10,20,30,40])
				let lineCount = random(20)
				for(var i=0;i<random(lineCount);i++){
					let lLan = 5
					g.stroke(0,100)
					g.line(-this.radius-10-lLan,-i*lineSp,-this.radius-10+lLan,-i*lineSp)
				}
				g.pop()
			}
			// g.ellipse(this.r+10,this.r+10,2,2)
			if (random()<0.001 && frameCount%10==0){
				g.stroke(0)
				g.noFill()
				g.ellipse(0,this.radius+10,random(this.radius))
			}
		

		
			// g.rotate(PI/4-PI/2)
			// g.rect(0,0,-this.r*2,2)
		g.pop()
	}
	update(){
		this.position.add(this.velocity)
		this.velocity.add(this.acceleration)		
		this.radius *= this.decayRate
		this.alive = this.radius>0.1
		if (random()<0.25 && frameCount % 15==0 && this.uniqueId%5==0){
			this.particleColor = random(colors)
		}
		
		let steplize = (n,l)=>int(n*l)/l
		// if (this.uniqueId%25==0){
			this.velocity.x = (steplize(noise(this.position.x/this.noiseScale,this.position.y/this.noiseScale)-0.5,this.movementSteps[0]))*this.horizontalSpeed
			this.velocity.y = (steplize(noise(this.position.y/this.noiseScale,this.position.x/this.noiseScale)-0.5,this.movementSteps[1]))*this.verticalSpeed
			
			let ang = atan2(this.position.y-height/2,this.position.x-width/2)
			let r = dist(this.position.x,this.position.y,width/2,height/2)
			
			//rotate center
			this.velocity.x += cos(ang+PI/2)*this.rotationFactor;
			this.velocity.y += sin(ang+PI/2)*this.rotationFactor;
// 		}else{
// 			this.v.x = (steplize(noise(this.p.x/50,this.p.y/50)-0.5,this.steps[0]))*this.xSpeedFactor
// 			this.v.y = (steplize(noise(this.p.y/50,this.p.x/50)-0.5,this.steps[1]))*this.ySpeedFactor
		
// 		}
		
		wormholes.forEach(w=>{
			let ang = atan2(this.position.y-w.p.y,this.position.x-w.p.x)
			let dd = dist(this.position.x,this.position.y,w.p.x,w.p.y)
			let ratio = map(dd,0,w.r, 1,0,true)
			let force = w.intensity*ratio*ratio
			
			//rotate center
			this.velocity.x += w.rotate* force* cos(ang+PI/2) + w.attract*  force* cos(ang);
			this.velocity.y += w.rotate*  force*  sin(ang+PI/2)+ w.attract*  force* sin(ang);
		})
		

		
		//test
		
// 		if (noise(this.p.x/120,this.p.y/120)<0.2){
			
// 			// originalGraphics.fill('red')
// 			// originalGraphics.ellipse(this.p.x,this.p.y,5,5)
// 			this.v.x+=sin(this.p.y/50)*50
// 			this.v.y+=cos(this.p.x/50)*50
// 		}
		
				
		//quantize angle
		if (noise(this.position.x/60,this.position.y/60)<0.2){
			let ang = atan2(this.velocity.x,this.velocity.y) 
			let amp = this.velocity.mag()
			let angStepCount = 8
			let newAng = int(ang/2/PI*angStepCount)/angStepCount*2*PI
			this.velocity.x = amp*cos(newAng)
			this.velocity.y = amp*sin(newAng)
			// originalGraphics.fill('red')
			// originalGraphics.ellipse(this.p.x,this.p.y,5,5)
			
		}
		
		
		// this.v.add(this.p.copy().sub(createVector(width/2,height/2)).mult(-0.002))
	}
	
}

let theShader,theShaderTexture;
let webGLCanvas
let originalGraphics
let overlayGraphics
let particles = []
let wormholes = []
let overallTexture
let bgColor
let sortedColors = []
function preload(){
	// randomSeed(3390)
	// noiseSeed(20)
	colors = random(themes)
	
	sortedColors = colors.sort((a,b)=>brightness(color(b))-brightness(color(a)))
	
	
	theShader = new p5.Shader(this.renderer,vert,frag)
	theShaderTexture = new p5.Shader(this.renderer,vert,frag_texture)
	// overallTexture = loadImage("canvas-light.jpeg") 
		
	
	features.style='normal'
	// features.style=random()<1?'stroke':'normal'
	// features.style=random()<0.2?'shape':features.style
	features.hasBgBorder = random()<0.5;
	features.rotateFactors = random([
		[0],
		[0],
		[0],
		[0],
		[0,0.05],
		[0,-0.05],
		[0.05,0,0,0,0,0,0,-0.05]
		
	])
	features.vNoiseScale = random([40,50,75,100,120])
	features.hasGrid = false
	features.wormholeCount = random([1,2,3,4,5])
}

function setup() {
	
	pixelDensity(2)
	let canvasWidth = window.innerWidth - 650; // 減去左邊面板寬度
	let canvasHeight = window.innerHeight - 300; // 減去頂部高度
	
	// 將 canvas 放入指定的容器中
	let canvas = createCanvas(canvasWidth, canvasHeight);
	canvas.parent('canvasWrapper');
	
	// 初始化量子電路
	renderCircuit();
	
	// 添加 dragend 事件到所有量子閘
	document.querySelectorAll('.gate').forEach(gate => {
		gate.addEventListener('dragend', handleDragEnd);
	});
	
	//prepare texture
	overallTexture = createGraphics(width,height,WEBGL)
	overallTexture.shader(theShaderTexture)
	theShaderTexture.setUniform('u_resolution',[width,height])
	overallTexture.rect(-width/2,-height/2,width,height)
	
	
	webGLCanvas = createGraphics(width,height,WEBGL)
	originalGraphics = createGraphics(width,height)
	overlayGraphics = createGraphics(width,height)
	
	webGLCanvas.noStroke()
	overlayGraphics.noStroke()
	originalGraphics.noStroke()
	
	let rx = random([-0.1,-0.05,0,0,0.05,0.1])*width;
	let	ry = random([-0.1,-0.05,0,0,0.05,0.1])*height
	let ra = random([-0.2,-0.1,0,0,0.1,0.2])
	
	for(let g of [originalGraphics,overlayGraphics]){
		// console.log(g)
		g.translate(rx,ry)
		g.translate(width/2,height/2)
		// g.rotate(ra)
		// if (!features.style=="normal"){
			g.scale(random([1,1.2,1.5,2,3]))
		// }
		g.translate(-width/2,-height/2)
	}

	
	background(100)
	
	originalGraphics.noStroke()
	
	// 使用量子參數設定背景顏色
	bgColor = color(quantumParameters.bgRed, quantumParameters.bgGreen, quantumParameters.bgBlue)
	
	// 根據風格調整
	if (features.style=="stroke") bgColor=color(255)
	if (features.style=="shape") bgColor=color(255)
	
	// bgColor = color('#f9f9f7')
	// bgColor=color(255)
	

	// originalGraphics.background(bgColor); 
	
	let pairId = int(random(6))

	let spanOptions =[8,10,12,20,32,44,60,68]
	let maxSizeOptions = [160,200,300,400,500,600,840,900]
	
	let minPairId = 0
	let maxPairId = random([5,6,7])
	let span = spanOptions[pairId]
	let maxSize = maxSizeOptions[pairId]
	let pairNoiseScale = random([10,20,100,200])

	let ignorePossibility = random([0.05,0.3])
	let gapScale = random([100,150,200,250])
	let gapRatio = random([0.3,0.35,0.4,0.45,0.5])
	let panScale = random([0,1,2,5,10,15,20,25])
	let panRatio = random([0,0,random([0,5,10,15])])
	
	// console.log(span,maxSize)
	//noprotect
	// 使用量子參數控制粒子生成
	let quantumParticleCount = quantumParameters.particleCount
	let particleIndex = 0
	
	for(let x=0;x<=width && particleIndex < quantumParticleCount;x+=span){
		if (noise(x/2)<ignorePossibility) continue
		//noprotect
		for(let y=0;y<=height && particleIndex < quantumParticleCount;y+=span){
			// if (noise(x,y)<ignorePossibility) continue
			if (noise(x/gapScale,y/gapScale)<=gapRatio) continue
			
			// 決定粒子顏色基於量子參數
			let particleColor
			if(random(100) < quantumParameters.randomColor) {
				particleColor = random(colors)
			} else {
				const noise = random(-quantumParameters.colorVariation, quantumParameters.colorVariation)
				const nr = constrain(quantumParameters.mainRed + noise, 0, 255)
				const ng = constrain(quantumParameters.mainGreen + noise, 0, 255)
				const nb = constrain(quantumParameters.mainBlue + noise, 0, 255)
				particleColor = color(nr, ng, nb)
			}
			
			particles.push(new Particle({
				position: createVector(x, y),
				radius: noise(x,y) * maxSize * random(1) * (quantumParameters.particleSize / 40),
				particleColor: particleColor
			}))
			
			let pairId = int(map(noise(x/pairNoiseScale,y/pairNoiseScale),0,1,minPairId,maxPairId))
			span = spanOptions[pairId]
			maxSize = maxSizeOptions[pairId]
			particleIndex++
		}
	}
	
	// particles.sort((a,b)=>random()<0.5)
	
	for(let i=0;i<features.wormholeCount;i++){
		let w = new Wormhole({
			p: createVector(random(-width*0.2,width*1.2),random(-height*0.2,height*1.2)),
			r: random(100,600),
			intensity: random([-1,1])/10,
			rotate: random([-1,1]),
			attract: random([-1,1])
		})
		wormholes.push(w)
		// overlayGraphics.push()
		// overlayGraphics.stroke('blue')
		// overlayGraphics.strokeWeight(5)
		// overlayGraphics.translate(w.p.x,w.p.y)
		// overlayGraphics.line(-10,-10,10,10)
		// overlayGraphics.line(-10,10,10,-10)
		// overlayGraphics.pop()
		// originalGraphics.ellipse(w.p.x,w.p.y,50,50)	
	}
}


function draw() {
	 

	
	webGLCanvas.shader(theShader)
	theShader.setUniform('u_resolution',[width,height])
	theShader.setUniform('u_time',millis()/1000)
	theShader.setUniform('u_mouse',[mouseX/width,mouseY/height])
	theShader.setUniform('u_tex',originalGraphics)
	theShader.setUniform('u_bgColor',[bgColor._getRed()/255.,bgColor._getGreen()/255.,bgColor._getBlue()/255.])
	theShader.setUniform('u_canvas_tex',overallTexture)
	
	webGLCanvas.clear()

	
	webGLCanvas.background(bgColor)
	background(100)
	fill(0)
	rect(0,0,width*2,height*2)
	
	webGLCanvas.rect(-width/2,-height/2,width,height)
	// webGLCanvas.noStroke()
	// webGLCanvas.push()
	// webGLCanvas.rotateY(frameCount/300)
	// webGLCanvas.sphere(500-frameCount/2)
	// webGLCanvas.pop()
	
	particles.forEach(p=>{
		p.update() 
		p.draw(originalGraphics)
		
		// if (random()<0.005 && frameCount<5000){
		// 	let p1 = random(particles), p2 = random(particles)
		// 	overlayGraphics.push()
		// 	overlayGraphics.blendMode(MULTIPLY)
		// 	overlayGraphics.stroke(0,2)
		// 	overlayGraphics.strokeWeight(0.4)
		// 	overlayGraphics.line(p1.p.x,p1.p.y,p2.p.x,p2.p.y)
		// 	overlayGraphics.pop()
		// }
		
	})
	particles = particles.filter(p=>p.alive)

	originalGraphics.noStroke()
	// originalGraphics.fill(255)
	// originalGraphics.noStroke()
	// originalGraphics.ellipse(mouseX, mouseY, 10, 10);
	
	
	fill(bgColor); 
	rect(0,0,width,height)
	
	push()
	let gridSpan = 40
	if (features.hasGrid){
		blendMode(MULTIPLY)
		//test grid
		for(let x=0;x<width;x+=gridSpan){
			stroke(0,20)
			line(x,0,x,height)
		}
		for(let y=0;y<height;y+=gridSpan){
			stroke(0,20)
			line(0,y,width,y)
		}
	}
	blendMode(BLEND)
	if (features.style=='normal'){
		image(webGLCanvas,0,0)
		
		push()
		// blendMode(MULTIPLY)
		
		// image(webGLCanvas,0,0)
		image(overlayGraphics,0,0)
		pop()
	}
	pop()
	// pop()
// 	push()
// 		blendMode(MULTIPLY)
	
		// image(originalGraphics,0,0)
// 	pop()
	// push()
	// 	// blendMode(ADD)
	// 	stroke(bgColor)
	// 	noFill()
	// 	strokeWeight(40)
	// 	rect(0,0,width,height)
	// pop()
	
	// push()
	// 		blendMode(MULTIPLY)
	// 		noStroke()
	// 		image(overallTexture,0,0)
	// 		// blendMode(SCREEN)
	// 		// image(overallTexture,0,0,1920,1080)
	// 		// image(overallTexture,0,0,height/1080*1920 ,height)
	// pop()
	// for(var i=0;i<height;i+=200){
	// 	stroke(bgColor)
	// 	strokeWeight(15)
	// 	line(0,i,width,i)
	// }
	
	if (features.style!='normal'){
		push()
		blendMode(MULTIPLY)
		
		image(webGLCanvas,0,0)
		image(overlayGraphics,0,0)
		pop()
	}
}
const frag_functions_default = `
  #define PI 3.141592653589793
  #define TAU 6.283185307179586
	
	float rand(vec2 c){
		return fract(sin(dot(c.xy ,vec2(12.9898,78.233))) * 43758.5453);
	}

	mat2 rotate2d(float _angle){
    return mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle));
	}

	mat2 scale2d(vec2 _scale){
			return mat2(_scale.x,0.0,
									0.0,_scale.y);
	}

	vec2 tile (vec2 _st, float _zoom) {
			_st *= _zoom;
			return fract(_st);
	}

	//	Classic Perlin 3D Noise 
	//	by Stefan Gustavson

	vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}
	vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}
	vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}

	float cnoise(vec3 P){
		vec3 Pi0 = floor(P); // Integer part for indexing
		vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1
		Pi0 = mod(Pi0, 289.0);
		Pi1 = mod(Pi1, 289.0);
		vec3 Pf0 = fract(P); // Fractional part for interpolation
		vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0
		vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		vec4 iy = vec4(Pi0.yy, Pi1.yy);
		vec4 iz0 = Pi0.zzzz;
		vec4 iz1 = Pi1.zzzz;

		vec4 ixy = permute(permute(ix) + iy);
		vec4 ixy0 = permute(ixy + iz0);
		vec4 ixy1 = permute(ixy + iz1);

		vec4 gx0 = ixy0 / 7.0;
		vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		gx0 = fract(gx0);
		vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		vec4 sz0 = step(gz0, vec4(0.0));
		gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		gy0 -= sz0 * (step(0.0, gy0) - 0.5);

		vec4 gx1 = ixy1 / 7.0;
		vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		gx1 = fract(gx1);
		vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		vec4 sz1 = step(gz1, vec4(0.0));
		gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		gy1 -= sz1 * (step(0.0, gy1) - 0.5);

		vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);

		vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		g000 *= norm0.x;
		g010 *= norm0.y;
		g100 *= norm0.z;
		g110 *= norm0.w;
		vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		g001 *= norm1.x;
		g011 *= norm1.y;
		g101 *= norm1.z;
		g111 *= norm1.w;

		float n000 = dot(g000, Pf0);
		float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		float n111 = dot(g111, Pf1);

		vec3 fade_xyz = fade(Pf0);
		vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		return 2.2 * n_xyz;
	}
	
	
float noise(vec2 p, float freq ){
	float unit = 1./freq;
	vec2 ij = floor(p/unit);
	vec2 xy = mod(p,unit)/unit;
	//xy = 3.*xy*xy-2.*xy*xy*xy;
	xy = .5*(1.-cos(PI*xy));
	float a = rand((ij+vec2(0.,0.)));
	float b = rand((ij+vec2(1.,0.)));
	float c = rand((ij+vec2(0.,1.)));
	float d = rand((ij+vec2(1.,1.)));
	float x1 = mix(a, b, xy.x);
	float x2 = mix(c, d, xy.x);
	return mix(x1, x2, xy.y);
}

	
	float pNoise(vec2 p, int res){
		// p+=u_noise_pan;
		float persistance = .5;
		float n = 0.;
		float normK = 0.;
		float f = 4.;
		float amp = 1.;
		int iCount = 0;
		//noprotect
		for (int i = 0; i<50; i++){
			n+=amp*noise(p, f);
			f*=2.;
			normK+=amp;
			amp*=persistance;
			if (iCount == res) break;
			iCount++;
		}
		float nf = n/normK;
		return nf*nf*nf*nf;
	}

	vec2 random2( vec2 p ) {
			return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
	}

`
const frag = `
	precision highp float;

	uniform vec2 u_resolution;
	uniform vec2 u_mouse;
	uniform float u_time;
	uniform vec3 u_lightDir;
	uniform vec3 u_col;
	uniform vec3 u_bgColor;
	uniform mat3 uNormalMatrix;
	uniform float u_pixelDensity;
	uniform sampler2D u_tex;
	uniform sampler2D u_canvas_tex; 

	//attributes, in
	varying vec4 var_centerGlPosition;
	varying vec3 var_vertNormal;
	varying vec2 var_vertTexCoord;

	${frag_functions_default}

	void main(){
		vec2 st = var_vertTexCoord.xy /u_resolution.xy*u_resolution.y;
		st.x*=u_resolution.x/u_resolution.y;
		vec2 stBorder =st;
		
		stBorder.x+=cnoise(vec3(st*1000.,100.))/500.;
		stBorder.y+=cnoise(vec3(st*1000.,1000.))/500.; 
		
		stBorder.x+=cnoise(vec3(st*100.,100.))/500.;
		stBorder.y+=cnoise(vec3(st*100.,1000.))/500.; 



	
		vec3 canvasOffset = texture2D(u_canvas_tex,st* vec2(u_resolution.x/u_resolution.y,1.)).rgb;
		st.x+=0.35/255.- canvasOffset.r/255.*3. ;
		st.y+=0.35/255.- canvasOffset.g/255.*3.  ;
		
		float distortFactor =  0.8;
		st.x+=  cnoise(vec3(st*2.,${(Math.random()*1000).toFixed(4)}))/(30.)*distortFactor  ;
		st.y+= cnoise(vec3(st*20.,${(Math.random()*1000).toFixed(4)}))/(30.)*distortFactor 
					+ cnoise(vec3(st/2.,${(Math.random()*1000).toFixed(4)}))/(100.)*distortFactor;
		
		// st.x+=cnoise(vec3(st*50.,100.))/300.  ;
		// st.y+=cnoise(vec3(st*100.,1000.))/300.;
		
		vec4 texColor0 = texture2D(u_tex,st);
		
		//offset color Blocks
		float offsetColor = 1./300.;
		stBorder.x-= texColor0.r*offsetColor;
		stBorder.y-=texColor0.g*offsetColor+ texColor0.b*offsetColor;
		
		vec4 texColor1 = texture2D(u_tex,st);
		 
		
		vec2 st2 = st;
		//brush feeling  
		float brushFactor = 400.;
		st2.x+=cnoise(vec3(st*1000.,100.))/brushFactor;
		st2.y+=cnoise(vec3(st*1000.,1000.))/brushFactor; 
 
		vec4 texColor2 = texture2D(u_tex,st2);
		
		float d = distance(vec2(0.5) ,st);  
		// texColor*=1.-d+0.3;
		// gl_FragColor= vec4(color,1.0)+texColor2; 
		
		float borderWidth = 20.;
		bool isBorder = stBorder.x*u_resolution.x<borderWidth
		|| (1.-stBorder.x)*u_resolution.x<borderWidth 
		|| stBorder.y*u_resolution.y<borderWidth 
		|| (1.-stBorder.y)*u_resolution.y<borderWidth;
		
		vec4 result ;
		result = texColor1*0.8 + (texColor1*texColor2/1.9+texColor1/4.+texColor2/4.)/5.;
		if ( isBorder){
			result.rgb= vec3(u_bgColor);
		} else {

			// if ( distance(result.rgb, u_bgColor.rgb)<0.01 ){
			// 	result.a=0.;
			// }
		} 
		gl_FragColor =result;	
	}
`



//ref 3d shader from https://www.openprocessing.org/sketch/881537

const vert = `
	precision highp float;

    // attributes, in
    attribute vec3 aPosition;
    attribute vec3 aNormal;
    attribute vec2 aTexCoord;

    // attributes, out
    varying vec3 var_vertPos;
    varying vec3 var_vertNormal;
    varying vec2 var_vertTexCoord;
		varying vec4 var_centerGlPosition;//原点
    
    // matrices
    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;
    uniform mat3 uNormalMatrix;
		uniform float u_time;
	uniform sampler2D u_tex;

	${frag_functions_default}

    void main() {
      vec3 pos = aPosition;
			
			
			// vec4 texColor = texture2D(u_tex,aTexCoord);
			// pos.x += (texColor.r-0.5)/4.;
			// pos.y += (texColor.g-0.5)/4.;
			// pos.z += (texColor.b-0.5)/4.;
			
			vec4 posOut = uProjectionMatrix * uModelViewMatrix * vec4(pos, 1.0);
			
			
			
      gl_Position = posOut;

      // set out value
      var_vertPos      = pos;
      var_vertNormal   =  aNormal;
      var_vertTexCoord = aTexCoord;
			var_centerGlPosition = uProjectionMatrix * uModelViewMatrix * vec4(0., 0., 0.,1.0);
    }
`;
const frag_texture = ` 
	precision highp float;

	uniform vec2 u_resolution;
	uniform vec2 u_mouse;
	uniform float u_time;
	uniform vec3 u_lightDir;
	uniform vec3 u_col;
	uniform mat3 uNormalMatrix;
	uniform float u_pixelDensity;
	uniform sampler2D u_tex; 

	//attributes, in
	varying vec4 var_centerGlPosition;
	varying vec3 var_vertNormal;
	varying vec2 var_vertTexCoord; 

	${frag_functions_default}

	void main(){
		vec2 st = var_vertTexCoord.xy /u_resolution.xy*min(u_resolution.x,u_resolution.y);
		st.x*=u_resolution.x/u_resolution.y;
			st.x*=u_resolution.x/u_resolution.y;
			float sc = 1.*u_resolution.x/100.;
			st*=sc;
			st*=vec2(3.,1.);
		
			// st.y = 1.0 - st.y;
			vec3 color = vec3(0.);
			color+=cnoise(vec3(st*20.,10.))/7./3.;
			color+=cnoise(vec3(st*30.,10.))/9./3.;
			color+=cnoise(vec3(st*10.,10.))/9./3.;
		
			color+=cnoise(vec3(st*200.,10.))/8.;
			color+=cnoise(vec3(st*300.,10.))/10.;
			color+=cnoise(vec3(st*100.,10.))/10.;
		
			color+=cnoise(vec3(st*200.,10.))/8.;
			color+=cnoise(vec3(st*300.,10.))/10.;
			color+=cnoise(vec3(st*100.,10.))/10.;
			color+=pNoise(st*10.,5)*pNoise(st*10.+2.,10)/2.;
			color+=pNoise(st*30.,5)*pNoise(st*40.+2.,10)/2.; 
			color/=2.;
		
			color = 1.-color; 
		
		// vec3 color = vec3(st.x,st.y,1.);
		gl_FragColor= vec4(color,1.0);
	}
`

// 初始化量子電路
document.addEventListener('DOMContentLoaded', function() {
    renderCircuit();
    updateParameterDisplay();
});

// 添加重製函數
function resetCanvas() {
    // 清除現有粒子
    particles = []
    
    // 重新初始化粒子
    let spanOptions = [8,10,12,20,32,44,60,68]
    let maxSizeOptions = [160,200,300,400,500,600,840,900]
    
    let pairId = int(random(6))
    let minPairId = 0
    let maxPairId = random([5,6,7])
    let span = spanOptions[pairId]
    let maxSize = maxSizeOptions[pairId]
    let pairNoiseScale = random([10,20,100,200])
    
    let ignorePossibility = random([0.05,0.3])
    let gapScale = random([100,150,200,250])
    let gapRatio = random([0.3,0.35,0.4,0.45,0.5])
    
    // 獲取當前量子參數設置
    const r = quantumParameters.mainRed
    const g = quantumParameters.mainGreen  
    const b = quantumParameters.mainBlue
    const randomColorProb = quantumParameters.randomColor
    const colorVariationValue = quantumParameters.colorVariation
    
    for(let x=0; x<=width; x+=span){
        if (noise(x/2)<ignorePossibility) continue
        for(let y=0; y<=height; y+=span){
            if (noise(x/gapScale,y/gapScale)<=gapRatio) continue
            
            // 決定粒子顏色
            let particleColor
            if(random(100) < randomColorProb) {
                particleColor = random(colors)
            } else {
                const noise = random(-colorVariationValue, colorVariationValue)
                const nr = constrain(r + noise, 0, 255)
                const ng = constrain(g + noise, 0, 255)
                const nb = constrain(b + noise, 0, 255)
                particleColor = color(nr, ng, nb)
            }
            
            particles.push(new Particle({
                position: createVector(x, y),
                radius: noise(x,y)*maxSize*random(1),
                particleColor: particleColor
            }))
            
            let pairId = int(map(noise(x/pairNoiseScale,y/pairNoiseScale),0,1,minPairId,maxPairId))
            span = spanOptions[pairId]
            maxSize = maxSizeOptions[pairId]
        }
    }
}

// 下載藝術作品功能
function downloadArtwork() {
    if (typeof saveCanvas !== 'undefined') {
        // 使用當前時間戳作為文件名
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const filename = `quantum-artwork-${timestamp}`;
        
        try {
            saveCanvas(filename, 'png');
            console.log('藝術作品已下載:', filename);
        } catch (error) {
            console.error('下載失敗:', error);
            alert('下載失敗，請確保畫布已完全載入');
        }
    } else {
        // 備用方案：手動創建下載鏈接
        try {
            const canvas = document.querySelector('canvas');
            if (canvas) {
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                link.download = `quantum-artwork-${timestamp}.png`;
                link.href = canvas.toDataURL('image/png');
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                console.log('藝術作品已下載');
            } else {
                alert('未找到畫布，請確保藝術作品已載入');
            }
        } catch (error) {
            console.error('下載失敗:', error);
            alert('下載失敗，請重試');
        }
    }
}
    </script>
</body>
</html>